<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Intro Go Hugo on </title>
    <link>http://devblog.dwarvesf.com/categories/intro-go-hugo/</link>
    <description>Recent content in Intro Go Hugo on </description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Thu, 10 Sep 2015 13:09:56 +0700</lastBuildDate>
    <atom:link href="http://devblog.dwarvesf.com/categories/intro-go-hugo/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Giới thiệu Interface trong GoLang</title>
      <link>http://devblog.dwarvesf.com/post/interface/</link>
      <pubDate>Thu, 10 Sep 2015 13:09:56 +0700</pubDate>
      
      <guid>http://devblog.dwarvesf.com/post/interface/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;Trong bài này mình sẽ trình bày những gì mình tìm hiểu được về interface trong Go, khái niệm, khai báo cũng như cách sử dụng và một vài ví dụ thực tế.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;khái-niệm:a38e724b1dfc1725327e2aea22a2a689&#34;&gt;Khái niệm&lt;/h2&gt;

&lt;p&gt;Interface là một dạng wrapper các khai báo hàm(chỉ là tên của hàm) ở mức độ prototype. Các hàm này sẽ được định nghĩa ở các lớp dẫn xuất, mỗi lớp dẫn xuất sẽ có cách định nghĩa lại hàm khác nhau tương ứng với mục đích sử dụng&lt;/p&gt;

&lt;h2 id=&#34;khai-báo:a38e724b1dfc1725327e2aea22a2a689&#34;&gt;Khai báo&lt;/h2&gt;

&lt;p&gt;Một interface với hàm SayYourName() trả về một string được khai báo như sau:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Hello interface{
	SayYourName() string 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;cách-sử-dụng:a38e724b1dfc1725327e2aea22a2a689&#34;&gt;Cách sử dụng&lt;/h2&gt;

&lt;p&gt;Interface trong Go follow concept Duck typing như sau:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;When I see a bird that walks like a duck and swims like a duck and quacks like a duck, I call that bird a duck.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Có nghĩa là nếu một con nào có thể đi như con vịt, bơi như con vịt và quạc quạc như con vịt thì tôi gọi đó là con vịt.&lt;/p&gt;

&lt;p&gt;Mình sẽ đưa một ví dụ cụ thể. Mình có struct User, struct này có một hàm SayYourName()&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
type User struct {
	FirstName, LastName string
}

func (u *User) SayYourName() string {
	return fmt.Sprintf(&amp;quot;%s %s&amp;quot;, u.FirstName, u.LastName)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Một hàm có param là interface Hello và trả về một string&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func Greet(n Hello) string {
	return fmt.Sprintf(&amp;quot;Dear %s&amp;quot;, n.SayYourName())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ở đây, hàm Greet nhận vào một param là interface Hello, và nó cũng chấp nhận &lt;b&gt;bất cứ param nào nếu nó có hàm SayYourName&lt;/b&gt;.&lt;br /&gt;
Thử chạy chương trình:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	u := &amp;amp;User{&amp;quot;Runi&amp;quot;, &amp;quot;Lazy&amp;quot;}
	fmt.Println(Greet(u))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Thật vậy ta có, kết quả &amp;ldquo;Dear Runi Lazy&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Chú ý là param truyền vào hàm Greet phải là những đối tượng có thể có chứa các hàm của riêng đối tượng đó, nhưng bắt buộc phải có  &lt;b&gt;tất cả&lt;/b&gt; những hàm của interface Hello. Giả sử thêm vào interface này một hàm Goodbye():&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Hello interface{
	SayYourName() string 
	Goodbye() string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Kết quả ta bị báo lỗi như sau:&lt;/p&gt;

&lt;p&gt;
&lt;figure class=&#34;third right&#34;&gt;
    
        &lt;img src=&#34;http://devblog.dwarvesf.com/images/interfacewrong.png&#34;  /&gt;
    
    
&lt;/figure&gt;

&lt;/p&gt;

&lt;h2 id=&#34;sử-dụng-interface-trong-go:a38e724b1dfc1725327e2aea22a2a689&#34;&gt;Sử dụng Interface trong Go&lt;/h2&gt;

&lt;p&gt;Ngoài interface có chứa khai báo hàm, interface còn một khái niệm là empty interface, hay interface{}.
Interface này không có hàm, cũng có nghĩa là tất cả các loại variables hay struct&amp;hellip; đều có thể thoả mãn làm param cho hàm nhận vào empty interface.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func DoSomething(v interface{}) {
   // ...
}
//Hàm này nhận vào bất cứ loại param nào.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Như vậy ta có thể sử dụng empty interface cho các hàm nào mà param truyền vào vẫn chưa xác định cụ thể. Khi vào trong hàm thì tuỳ trường hợp sẽ có các cách tuỳ biến để convert về giá trị chúng ta cần.&lt;/p&gt;

&lt;p&gt;Ví dụ, ta có hàm PrintAll nhận vào một mảng giá trị empty interface.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func PrintAll(vals []interface{}) {
    for _, val := range vals {
        fmt.Println(val)
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Trong hàm main ta tiến hành convert:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
func main() {
    names := []string{&amp;quot;stanley&amp;quot;, &amp;quot;david&amp;quot;, &amp;quot;oscar&amp;quot;}
    vals := make([]interface{}, len(names))
    for i, v := range names {
        vals[i] = v
    }
    PrintAll(vals)
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Một ví dụ khác, mình sưu tầm từ blog &lt;a href=&#34;http://jordanorelli.com/post/32665860244/how-to-use-interfaces-in-go&#34;&gt;how to use interface in Go&lt;/a&gt;:&lt;br /&gt;
Khi nhận response từ Twitter API thì date time có dạng timestamp như sau:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;Thu May 31 00:00:01 +0000 2012&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Dưới dây là một hàm dùng để in ra kiểu của timeStamp khi nhận từ response:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var input = `
{
    &amp;quot;created_at&amp;quot;: &amp;quot;Thu May 31 00:00:01 +0000 2012&amp;quot;
}
`

func main() {
    var val map[string]interface{}

    if err := json.Unmarshal([]byte(input), &amp;amp;val); err != nil {
        panic(err)
    }

    fmt.Println(val)
    for k, v := range val {
        fmt.Println(k, reflect.TypeOf(v))
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Chạy hàm trên ta được :&lt;/p&gt;

&lt;p&gt;
&lt;figure class=&#34;third right&#34;&gt;
    
        &lt;img src=&#34;http://devblog.dwarvesf.com/images/returntwitter.png&#34;  /&gt;
    
    
&lt;/figure&gt;

&lt;/p&gt;

&lt;p&gt;Hum.. timeStamp mà lại kiểu string thì chưa hợp lý lắm, thử parse lại về trực tiếp kiểu time.Time&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    var val map[string]time.Time
    if err := json.Unmarshal([]byte(input), &amp;amp;val); err != nil {
        panic(err)
    }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Thử chạy lại:&lt;/p&gt;

&lt;p&gt;
&lt;figure class=&#34;third right&#34;&gt;
    
        &lt;img src=&#34;http://devblog.dwarvesf.com/images/panicinterface.png&#34;  /&gt;
    
    
&lt;/figure&gt;

&lt;/p&gt;

&lt;p&gt;Lỗi này xảy ra vì không thể parse chuỗi kia về time.Time được (Twitter API được viết bằng Ruby, cách parse sẽ khác với Go).&lt;br /&gt;
Vậy chúng ta thử viết lại hàm parse chuỗi. Ta có interface Unmarshal, được lấy từ &lt;a href=&#34;http://golang.org/pkg/encoding/json/#Unmarshaler&#34;&gt;Encode Json Package&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Unmarshaler interface {
    UnmarshalJSON([]byte) error
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ta cần viết lại hàm UnmarshalJSON để có thể parse về timeStamp(sử dụng RubyDate)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Timestamp time.Time

func (t *Timestamp) UnmarshalJSON(b []byte) error {
     v, err := time.Parse(time.RubyDate, string(b[1:len(b)-1]))
    if err != nil {
        return err
    }
    *t = Timestamp(v)
    return nil
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Khi đó, hàm main sẽ được viết lại như sau:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	var val map[string]Timestamp

	if err := json.Unmarshal([]byte(input), &amp;amp;val); err != nil {
		panic(err)
	}

	fmt.Println(val)
	for k, v := range val {
		fmt.Println(k, reflect.TypeOf(v))
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Chạy chương trình ta được kết quả:

&lt;figure class=&#34;third right&#34;&gt;
    
        &lt;img src=&#34;http://devblog.dwarvesf.com/images/interfacetimestamp.png&#34;  /&gt;
    
    
&lt;/figure&gt;

&lt;/p&gt;

&lt;p&gt;Như vậy chúng ta đã vừa tạo một đối tượng có hàm UnmarshalJSON để có thể truyền vào hàm json.Unmarshal trong package encoding/json nhờ đó có được kết quả mong muốn.&lt;/p&gt;

&lt;h2 id=&#34;lời-kết:a38e724b1dfc1725327e2aea22a2a689&#34;&gt;Lời kết&lt;/h2&gt;

&lt;p&gt;Trên đây là những gì mình tìm hiểu được trong quá trình sử dụng interface trong Go. Interface là một trong những kĩ thuật đặc trưng của Go, mong nhận được ý kiến đóng góp từ các bạn.
Nếu có điều gì muốn trao đổi, liên hệ qua mail thach@dwarvesf.com với mình nha.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Docker và những điều cần biết.</title>
      <link>http://devblog.dwarvesf.com/post/docker-introduction/</link>
      <pubDate>Sun, 09 Aug 2015 10:45:19 +0700</pubDate>
      
      <guid>http://devblog.dwarvesf.com/post/docker-introduction/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Gần đây Docker đang gây được nhiều chú ý trong cộng đồng công nghệ thế giới, với nhiều hứa hẹn trong tương lai. Các hãng công nghệ lớn như Google, Amazon, Microsoft, IBM, Ebay… đã bắt đầu hỗ trợ Docker trên nền tảng của họ.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Vậy Docker là gì, có gì thú vị ?  Chúng ta hãy cùng nhau điểm qua một số điều dưới đây để hiểu hơn về Docker và có thể triển khai được website Golang được viết với framework Beego.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;docker-là-gì:cdde93ef5507b118dc926636dcdb2b77&#34;&gt;Docker là gì?&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Docker là một nền tảng mở dành cho các lập trình viên, quản trị hệ thống dùng để xây dựng, vận chuyển và chạy các ứng dụng. Ban đầu viết bằng Python, hiện tại đã chuyển sang Go-lang.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;vậy-docker-khác-gì-so-với-máy-ảo:cdde93ef5507b118dc926636dcdb2b77&#34;&gt;Vậy docker khác gì so với máy ảo ?&lt;/h2&gt;

&lt;p&gt;
&lt;figure class=&#34;third right&#34;&gt;
    
        &lt;img src=&#34;http://devblog.dwarvesf.com/images/2015-08-09-screen-shoot-docker-compare-vm.png&#34;  /&gt;
    
    
&lt;/figure&gt;

&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Ở hình trên, ta có thể thấy như sau:

&lt;ul&gt;
&lt;li&gt;Máy ảo (virtual machine): mỗi máy ảo gồm các ứng dụng, các file nhị phân, thư viện, tất cả users hệ thống. Chúng tạo tạo nên một lượng dữ liệu rất lớn, có thể lên đến hơn 10GBs.&lt;/li&gt;
&lt;li&gt;Với Docker container: chỉ chứa những ứng dụng và những thứ cần thiết để chạy ứng dụng, có khả năng share kernel với những container khác. Chúng chạy độc lập trên hệ thống. Chúng cũng không bị hạn chế bởi cấu hình máy nào, vì docker container có thể chạy trên bất kì máy tính, bất kì cấu hình, hoặc thậm chí trên cả cloud.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;các-thành-phần-của-docker:cdde93ef5507b118dc926636dcdb2b77&#34;&gt;Các thành phần của Docker&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Docker Engine: còn được gọi là Docker, dùng để tạo và chạy các “container”&lt;/li&gt;
&lt;li&gt;Kitematic: là giao diện GUI cho Docker&lt;/li&gt;
&lt;li&gt;Docker Hub: là 1 dịch vụ host public của Docker để quản lý các image của bạn.&lt;/li&gt;
&lt;li&gt;Docker Compose: là 1 công cụ để tạo và chạy nhiều containers cùng lúc. Với Docker Compose, bạn chỉ việc định nghĩa các containers trên 1 file (text) và chạy 1 dòng lệnh duy nhất, sau đó mọi thứ sẽ được docker cài đặt, setup và chạy ứng dụng như ý bạn.&lt;/li&gt;
&lt;li&gt;Docker Trusted Registry: là dịch vụ cung cấp private image.&lt;/li&gt;
&lt;li&gt;Docker Registry: nơi để lưu trữ các images của cộng đồng Docker.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;một-số-khái-niệm:cdde93ef5507b118dc926636dcdb2b77&#34;&gt;Một số khái niệm&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Image: là 1 đối tượng chứa sẵn cấu hình. Ví dụ: image có sẵn hệ điều hành ubuntu, image có sẵn Golang, … Các thao tác với image: build, run, remove&lt;/li&gt;
&lt;li&gt;Container: là 1 đối tượng mà ứng dụng chạy trong đó. Container được tạo từ image. Các thao tác với container: ps, start, stop, restart, logs, remove&lt;/li&gt;
&lt;li&gt;Dockerfile: là 1 file (text), để định nghĩa 1 image sẽ được tạo như thế nào, gồm các ứng dụng nào được cài sẵn bên trong đó.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;tạo-web-golang-bằng-framework-beego-bằng-dockerfile:cdde93ef5507b118dc926636dcdb2b77&#34;&gt;Tạo web Golang bằng framework Beego bằng Dockerfile&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Ta bắt đầu với việc tạo 1 Dockerfile, ở đây tôi sử dụng “vi” để tạo file, với nội dung như sau:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;# vì ta chạy code golang nên ta cần image là google/golang có sẵn trên docker hub
FROM google/golang

# ta get source beego về
RUN go get github.com/astaxie/beego 
RUN go get github.com/beego/bee

# set vị trí path hiện tại
WORKDIR /gopath/src/

# tạo 1 project bằng lệnh bee new
RUN bee new app

# set vị trí path để chạy app beego
WORKDIR /gopath/src/app

# set port chạy app
EXPOSE 8080

# set lệnh để chạy app
CMD bee run
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Để biết thêm về syntax tạo 1 image bằng Dockerfile, các bạn có thể xem tại: &lt;a href=&#34;https://docs.docker.com/articles/dockerfile_best-practices/&#34;&gt;https://docs.docker.com/articles/dockerfile_best-practices/&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Ta save file lại, và chạy lệnh:&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;docker build –t beego . (các bạn đừng quên dấu . phía cuối :D)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Lệnh trên thực hiện các thao tác sau:

&lt;ol&gt;
&lt;li&gt;Đặt tag name cho image là beego.&lt;/li&gt;
&lt;li&gt;Docker build image dựa trên file Dockerfile mà ta đang đứng ở path hiện tại.&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
&lt;figure class=&#34;third right&#34;&gt;
    
        &lt;img src=&#34;http://devblog.dwarvesf.com/images/2015-08-09-screen-shoot-docker-init-dockerfile.png&#34;  /&gt;
    
    
&lt;/figure&gt;

&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Ta kiểm tra các images được tạo bằng lệnh:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;docker images
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;
&lt;figure class=&#34;third right&#34;&gt;
    
        &lt;img src=&#34;http://devblog.dwarvesf.com/images/2015-08-09-screen-shoot-docker-images.png&#34;  /&gt;
    
    
&lt;/figure&gt;

&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Sau đó, ta chạy lệnh:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;docker run –-name demo-beego-app –p 8080:8080 –d beego
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Lệnh trên thực hiện các thao tác sau:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Set name (&amp;ndash;name) cho container sẽ được tạo là demo-beego-app.&lt;/li&gt;
&lt;li&gt;Đặt map port (-p) từ port bên ngoài (bên trái) 8080 vào port bên trong docker (bên phải) là 8080.&lt;/li&gt;
&lt;li&gt;Detach container (-d) chạy background.&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Sau khi chạy lệnh trên, chúng ta đã có 1 web beego chạy trên docker container ☺. Giờ chúng ta log thử bằng browser:&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
&lt;figure class=&#34;third right&#34;&gt;
    
        &lt;img src=&#34;http://devblog.dwarvesf.com/images/2015-08-09-screen-shoot-docker-beego.png&#34;  /&gt;
    
    
&lt;/figure&gt;

&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Bài viết ghi lại những hiểu biết của tôi trong quá trình tìm hiểu và sử dụng Docker còn khá cơ bản. Rất mong nhận được góp ý từ các bạn ☺.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Các bạn cũng có thể tìm hiểu ở trang chủ: &lt;a href=&#34;https://docs.docker.com/index.html&#34;&gt;https://docs.docker.com/index.html&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>REVEL - MVC server side web framework Cho Golang</title>
      <link>http://devblog.dwarvesf.com/post/revel-installation/</link>
      <pubDate>Thu, 05 Feb 2015 14:36:15 +0700</pubDate>
      
      <guid>http://devblog.dwarvesf.com/post/revel-installation/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Hiện tại đã có khá nhiều framework viết bằng Go giúp cho việc lập trình ứng dụng web được dễ dàng và hệ thống hơn như revel, beego, martini, goji, … Mỗi framework có những điểm mạnh riêng, nhưng ở bài này tui sẽ hướng dẫn các bạn cài đặt và viết ứng dụng myapp đầu tiên bằng REVEL.&lt;br&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Trong đó, beego và revel là 2 framework cung cấp mô hình MVC giúp chúng ta dễ dàng code và maintain hơn trong việc tạo ứng dụng web. &lt;br&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Về phía martini và goji, 2 framework này tương đối giống nhau (gần giống với nodejs), nhưng chúng không hỗ trợ render view nên theo tui sẽ thích hợp hơn khi sử dụng với mục đích làm server RESTful hay cập nhật real-time cho client. &lt;br&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Chúng ta tiếp tục so sánh giữa beego và revel:&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Hot-compile/reload:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Cả 2 đều hỗ trợ hot-compile/reload (không cần phải restart server để chạy code mới), nhưng ở beego, file được tự động compile mỗi khi có thay đổi (mỗi khi save), còn Revel thì không như vậy, Revel sẽ đợi đến khi nhận được request mới thực hiện compile code mới, ở mặt này theo tui thấy Revel có vẻ như sử dụng ít tài nguyên hơn. &lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ORM:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Revel không hỗ trợ ORM nhưng có ví dụ cách sử dụng GORP. Beego lại tự build cho mình ORM. Ở phần database, tôi sẽ hướng dẫn các bạn kết nối dễ dàng với upper.io &lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Template engine:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Cả 2 đều sử dụng template engine của Golang &lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Vấn đề dev:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Revel cho phép ta code và xem kết quả tốt hơn, chỉ việc refresh để xem kết quả, và kết quả hiện trên browser dù cho có lỗi, chúng vẫn được hiện lên browser. Beego thì không hiện lên browser, beego hiện lỗi lên console &lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Theo cá nhân tui, phần Route của Revel khá rõ ràng và gần giống như các framework PHP khác, beego thì không, nên tui sẽ thử chọn Revel để dev xem sao :D. &lt;br&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;trước-hết-là-cài-đặt-go:16b14fe962c3a7485d600cb2de0cc111&#34;&gt;Trước hết là cài đặt Go&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;sudo apt-get update&lt;/code&gt;&lt;br&gt;
&lt;code&gt;sudo apt-get install golang&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;tiếp-đến-là-git:16b14fe962c3a7485d600cb2de0cc111&#34;&gt;Tiếp đến là  git&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;sudo apt-get install git&lt;/code&gt; &lt;br&gt;
&lt;code&gt;sudo apt-get install build-essential libssl-dev libcurl4-gnutls-dev libexpat1-dev gettext unzip&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;và-cuối-cùng-là-mercurial:16b14fe962c3a7485d600cb2de0cc111&#34;&gt;Và cuối cùng là mercurial&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;sudo apt-get install python-setuptools python-dev build-essential&lt;/code&gt; &lt;br&gt;
&lt;code&gt;sudo easy_install -U mercurial&lt;/code&gt;&lt;br&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Việc cài đặt Git và mercurial cho phép &lt;code&gt;go get&lt;/code&gt; tải về một số dependencies cần thiết cho việc cài đặt revel&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;cấu-hình-gopath:16b14fe962c3a7485d600cb2de0cc111&#34;&gt;Cấu hình GOPATH&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Tạo 1 folder: &lt;code&gt;mkdir ~/goRevel&lt;/code&gt; &lt;br&gt;&lt;/li&gt;
&lt;li&gt;Thông báo cho Go biết &lt;b&gt;GOPATH&lt;/b&gt; là folder vừa tạo: &lt;code&gt;export GOPATH=~/goRevel&lt;/code&gt; &lt;br&gt;&lt;/li&gt;
&lt;li&gt;Lưu &lt;b&gt;GOPATH&lt;/b&gt; để sử dụng cho 1 shell session: &lt;code&gt;echo export GOPATH=$GOPATH &amp;gt;&amp;gt; ~/.bash_profile&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;giờ-chúng-ta-đã-có-thể-cài-đặt-revel:16b14fe962c3a7485d600cb2de0cc111&#34;&gt;Giờ chúng ta đã có thể cài đặt REVEL&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;go get github.com/REVEL/REVEL&lt;/code&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;Dòng lệnh trên thực hiện 2 việc sau:&lt;br&gt;
+ Go sử dụng git để tải repository vào &lt;code&gt;$GOPATH/src/github.com/revel/revel/&lt;/code&gt;&lt;br&gt;
+ Go tìm tất cả những dependencies cần thiết và chạy &lt;code&gt;go get&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;và-cài-đặt-revel-tool:16b14fe962c3a7485d600cb2de0cc111&#34;&gt;và cài đặt REVEL tool&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;go get github.com/REVEL/cmd/REVEL&lt;/code&gt; &lt;br&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Công cụ REVEL command line cho phép bạn tạo(new), chạy ứng dụng(run) và đóng gói ứng dụng(package) và 1 số chức năng khác để sử dụng REVEL tiện hơn.  &lt;br&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Để có thể sử dụng được các lệnh REVEL ở bất cứ đâu, bạn cần phải lưu &lt;b&gt;$GOPATH/bin&lt;/b&gt; vào .bashrc bằng cách copy 2 dòng sau vào cuối file .bashrc: &lt;br&gt;
&lt;code&gt;export GOPATH=~/goRevel&lt;/code&gt;  &lt;br&gt;
&lt;code&gt;export PATH=&amp;quot;$PATH:$GOPATH/bin&amp;quot;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;kiểm-tra-cài-đặt:16b14fe962c3a7485d600cb2de0cc111&#34;&gt;Kiểm tra cài đặt&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;revel help&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;tạo-1-ứng-dụng-web:16b14fe962c3a7485d600cb2de0cc111&#34;&gt;Tạo 1 ứng dụng web&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;cd $GOPATH&lt;/code&gt; &lt;br&gt;
&lt;code&gt;revel new myapp&lt;/code&gt; &lt;br&gt;&lt;/p&gt;

&lt;p&gt;và bạn đã có thể chạy ứng dụng bằng lệnh sau: &lt;br&gt;
    &lt;code&gt;revel run myapp&lt;/code&gt; &lt;br&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Khi đó, REVEL sẽ chạy trên localhost với port là 9000 và bạn sẽ thấy: &lt;br&gt;&lt;/p&gt;

&lt;p&gt;
&lt;figure class=&#34;third right&#34;&gt;
    
        &lt;img src=&#34;http://devblog.dwarvesf.com/images/2015-02-05-revel-installation-run-my-app.png&#34;  /&gt;
    
    
&lt;/figure&gt;

&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Vậy là bạn đã cài đặt và chạy thành công ứng dụng đầu tiên bằng REVEL. &lt;br&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Ở bài sau, tui sẽ hướng dẫn các bạn làm việc với Controller, View, Routing và Parameters &lt;br&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;lời-kết:16b14fe962c3a7485d600cb2de0cc111&#34;&gt;Lời kết&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Việc cài đặt và chạy ứng dụng bằng REVEL không quá khó, nhưng nó lại đem đến cho bạn môi trường mvc gần tương tự như PHP giúp bạn có thể thích nghi nhanh chóng với việc code web bằng Golang, một ngôn ngữ còn tương tối mới và đang có cộng đồng khá đông đảo. Đó là một điều khá thuận lợi cho việc phát triển mạnh hơn của Golang. &lt;br&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;Nếu có vấn đề gì trong quá trình cài đặt, xin hãy comment bên dưới hoặc có thể gửi mail đến cho tui theo địa chỉ: ivkeanle@gmail.com&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Giới thiệu về Go</title>
      <link>http://devblog.dwarvesf.com/post/go-introduction/</link>
      <pubDate>Wed, 28 Jan 2015 23:49:15 +0700</pubDate>
      
      <guid>http://devblog.dwarvesf.com/post/go-introduction/</guid>
      <description>

&lt;p&gt;Tới thời điểm này, khá nhiều ngôn ngữ đã ra đời phục vụ việc lập trình cho phía Server-side như: PHP, Ruby on Rails, Python, NodeJs&amp;hellip; Mỗi ngôn ngữ đều có những ưu khuyết điểm riêng. Ở đây, tui sẽ giới thiệu một ngôn ngữ còn khá lạ lẫm với người Việt, đó là Go - một ngôn ngữ lập trình Server-side được phát triển bởi Google.&lt;/p&gt;

&lt;h2 id=&#34;giới-thiệu-go:f8019ab515cb984996d86c9fe8eb09ec&#34;&gt;Giới thiệu Go&lt;/h2&gt;

&lt;p&gt;Go là một ngôn ngữ lập trình đồng thời (Concurrent Program) được Google giới thiệu lần đầu tiên vào nằm 2009. Go được các thành viên phát triển nói đến về một ngôn ngữ cho server, được phát triển cho cộng đồng trên nền C.&lt;/p&gt;

&lt;p&gt;Go được ví như C - rút gọn. Những gì bạn có thể viết được trên C, bạn có thể viết được trên Go với tốc độ nhanh hơn gấp 5 lần với khác biệt rất nhỏ. Có thể đối với những bạn thường lập trình trên C# hay Java thì Go nhìn có vẻ khá lạ lẫm, nhưng khi bạn đã làm quen dc với Go, bạn sẽ thấy Go khá thú vị và tốc độ lập trình rất nhanh (như tui đã đề cập trước đó)&lt;/p&gt;

&lt;p&gt;Một trong những điểm tui thích nhất ở Go là tốc độ xử lý. Trong khi C được đánh giá có tốc độ xử lý cực nhanh, thì Go chỉ bị C bỏ lại với khoảng cách rất gần! Trước khi nhìn vào benchmark của Go, tui sẽ giởi thiệu với các bạn các cú pháp syntax Go chuẩn, các kiểu dữ liệu cơ bản, và so sánh nó với C.&lt;/p&gt;

&lt;h2 id=&#34;go-một-ngôn-ngữ-server-ngắn-gọn:f8019ab515cb984996d86c9fe8eb09ec&#34;&gt;Go, một ngôn ngữ server ngắn gọn&lt;/h2&gt;

&lt;p&gt;Nói đến đây, bạn có thấy Go thú vị và hấp dẫn hơn một tẹo rồi phải không? Mong là vậy! Dù rồi hay chưa, tui sẽ tăng tính thuyết phục và đặc sắc của Go bằng cách cho bạn xem những syntax đẹp và so sánh nó với C!
Thứ nhất, khai báo biến (variable) trong Go vô cùng ngắn gọn. Thay vì khai báo cụ thể kiểu dữ liệu của biến, Go có bộ tham chiếu kiểu dữ liệu (type inference) thực hiện việc gán kiểu và khởi tạo biến cho chúng ta. Để khai báo một biến đơn giản&amp;hellip;
Trong C:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int myVar = 33;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Trong Go:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;myVar := 33
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ngắn gọn hơn C, bạn có thể thấy như thế! Không chỉ có thế, Go không đòi hỏi kết thúc câu lệnh bằng dấu “;”, trả về nhiều kết quả trong function, và có thể trả về cặp (pair) kết quả và lỗi cho bạn (result, err). Pair cũng là cách chuẩn để xử lý lỗi trong Go. Tôi sẽ đề cập kỹ hơn ở các bài viết về syntax trong Go.
Hơn vậy, bạn có thể định nghĩa một biến bằng utf-8, một điều khá mới mẻ trong Go, ví dụ:
&lt;code&gt;biếnSố := 33&lt;/code&gt;
Bây giờ, ta tiến hành xét một chương trình Hello World trong Go và C:&lt;/p&gt;

&lt;p&gt;helloworld.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
 
int main ()
{
  printf (&amp;quot;Hello World!\n&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;helloworld.go&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main
 
import (
    &amp;quot;fmt&amp;quot;
)
 
func main() {
    fmt.Println(&amp;quot;Hello World!&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Chúng ta có thể thấy được sự tương đồng giữa Go và C qua đoạn code trên
Bạn sẽ thấy được Go ngắn gọn hơn C rõ ràng hơn khi bạn viết các chương trình lớn, phức tạp và cần xử lý đồng thời (concurrency). Có một bài blog so sánh C và Go, cũng như các chi tiết về những lợi thế về syntax của Go so với C: &lt;a href=&#34;http://www.syntax-k.de/projekte/go-review&#34;&gt;http://www.syntax-k.de/projekte/go-review&lt;/a&gt;
Tiếp theo. chúng ta sẽ so sánh khả năng chịu tải của Go để xem Go có thực sự chịu tải tốt đúng như tuyên bố của những lập trình viên hay không&lt;/p&gt;

&lt;h2 id=&#34;khả-năng-chịu-tải-của-go:f8019ab515cb984996d86c9fe8eb09ec&#34;&gt;Khả năng chịu tải của Go&lt;/h2&gt;

&lt;p&gt;Hãy nhìn cách Go chạy một loạt các chương trình đơn giản nhưng lặp đi lặp lại trong bảng dưới đây:&lt;/p&gt;

&lt;p&gt;
&lt;figure class=&#34;third right&#34;&gt;
    
        &lt;img src=&#34;http://devblog.dwarvesf.com/images/2015-01-28-go-vs-ruby.png&#34;  /&gt;
    
    
&lt;/figure&gt;

&lt;/p&gt;

&lt;p&gt;( Website test trực tuyến: &lt;a href=&#34;http://benchmarksgame.alioth.debian.org/&#34;&gt;http://benchmarksgame.alioth.debian.org/&lt;/a&gt; )&lt;/p&gt;

&lt;p&gt;Như chúng ta thấy từ số liệu thống kê, Golang hiệu quả hơn Ruby rất nhiều!!! Trong chương trình đầu tiên - ‘fasta-redux’, Ruby mất 110 giây để thực thi xong, nhưng Go chỉ mất 1.79 giây. Nhanh hơn gấp gần 100 lần! Quá ấn tượng phải không!!!&lt;/p&gt;

&lt;p&gt;Go không chỉ ấn tượng về tốc độ xử lý, mà còn thuận lợi về xử lý đồng thời hơn hầu hết các ngôn ngữ server hiện giờ. Go sử dụng các Goroutines (tui sẽ nói rõ hơn về Goroutlines ở những bài viết sau).&lt;/p&gt;

&lt;p&gt;Go đã cung cấp được chúng ta một ngôn ngữ lập trình ở server với tốc độ cực nhanh, một cú pháp ngắn gọn, hằng trăm package mặc định hữu dụng, cơ chế xử lý đa luồng đồng thời, và vô số thư viện được phát triển bởi các lập trình viên trên khắp thế giới. Tất cả giúp chúng ta xây dựng website, server bằng Go một cách nhanh và hiệu quả nhất.&lt;/p&gt;

&lt;h2 id=&#34;tóm-tắt:f8019ab515cb984996d86c9fe8eb09ec&#34;&gt;Tóm tắt&lt;/h2&gt;

&lt;p&gt;Với tuổi đời còn khá non trẻ (từ 2009) so với những ngôn ngữ khác (C hơn 40 năm, C++ hơn 30 năm, Ruby khoảng 20 năm, Java cỡ 17 năm, C# tầm 10-12 năm&amp;hellip;) thì 5 năm thực sự là khoảng thời gian không nhiều để ta so sánh những sản phẩm nổi bật được viết và phát hành bằng Go so với những ngôn ngữ khác. Tuy nhiên, Go đang được Google và cộng đồng lập trình viên tiếp tục phát triển và hoàn thiện. Tin vui là hiện nay, cộng đồng quan tâm đến Go trên thế giới không nhỏ!&lt;/p&gt;

&lt;p&gt;Cộng đồng Go lớn nhất hiện nay trên thế giới là &lt;a href=&#34;http://blog.gopheracademy.com/&#34;&gt;&lt;code&gt;Gopherarcademy&lt;/code&gt;&lt;/a&gt;, bên cạnh đó còn có  &lt;a href=&#34;http://go.meetup.com/&#34;&gt;&lt;code&gt;GoMeetUp&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Một trong những event lớn về Go trong thời gian gần đây là ngày 23 - 25/01/2015 vừa qua, &lt;a href=&#34;http://gophergala.com/&#34;&gt;&lt;code&gt;GopherGala&lt;/code&gt;&lt;/a&gt; đã đứng ra tổ chức sự kiện Hackathon đầu tiên cho Go trên toàn thế giới&lt;/p&gt;

&lt;p&gt;Go đang dần được chấp nhận và triển khai rộng rãi trên nhiều Startup và Công ty thương mại. Nhiều nhà cung cấp Saas/ Paas sử dụng Go trong dự án của họ. Dịch vụ gửi mail &lt;a href=&#34;http://sendgrid.com/blog/convince-company-go-golang/&#34;&gt;&lt;code&gt;SendGrid&lt;/code&gt;&lt;/a&gt; cũng đang áp dụng Go để xây dựng hệ thống mạnh mẽ hơn, nhanh hơn và đáng tin cậy hơn!&lt;/p&gt;

&lt;p&gt;Túm cái váy lại, nếu bạn đang tìm kiếm một ngôn ngữ lập trình đồng thời, song song, đơn giản, sexy và tuyệt vời, hãy đến với Go!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Hướng dẫn nhiều thành viên cùng viết bài trên Hugo</title>
      <link>http://devblog.dwarvesf.com/post/gohugo-tips/</link>
      <pubDate>Tue, 27 Jan 2015 16:19:17 +0700</pubDate>
      
      <guid>http://devblog.dwarvesf.com/post/gohugo-tips/</guid>
      <description>&lt;p&gt;Tiếp theo bài trước, sau khi đã cấu hình và deploy thư mục &lt;code&gt;source/&lt;/code&gt; chứa các file &lt;code&gt;.md&lt;/code&gt; và thư mục &lt;code&gt;public/&lt;/code&gt; chứa html tĩnh đã được dịch ra thì Github của tui sẽ như sau:&lt;/p&gt;

&lt;p&gt;
&lt;figure class=&#34;third right&#34;&gt;
    
        &lt;img src=&#34;http://devblog.dwarvesf.com/images/2015-01-27-github-dwarves.png&#34;  /&gt;
    
    
&lt;/figure&gt;

&lt;/p&gt;

&lt;p&gt;Để các thành viên khác có thể cùng đóng góp bài viết, tui cần phải đảm bảo họ có quyền truy cập vào 2 repo đó. Các thành viên khác cần có account Github và được add vào &lt;code&gt;Setting &amp;gt; Collaborators&lt;/code&gt; của từng repo. &lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:45c83b4096b0a8a9601d43555bed992a:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:45c83b4096b0a8a9601d43555bed992a:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;
&lt;figure class=&#34;third right&#34;&gt;
    
        &lt;img src=&#34;http://devblog.dwarvesf.com/images/2015-01-27-github-setting.png&#34;  /&gt;
    
    
&lt;/figure&gt;

&lt;/p&gt;

&lt;p&gt;Sau khi được cấp phát quyền truy cập vào đó, với vai trò là một thành viên mới, bạn sẽ phải clone 2 repo đó về bằng câu lệnh:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone git@github.com:dwarvesf/dwarvesf-hugo.git
$ cd dwarvesf-hugo
$ git clone --recursive git@github.com:dwarvesf/dwarvesf.github.io.git public/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Dùng &lt;code&gt;git remote&lt;/code&gt; để kiểm tra xem các folder còn trỏ đúng vào các repo hay không:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git remote -v
$ cd public | git remote -v
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;
&lt;figure class=&#34;third right&#34;&gt;
    
        &lt;img src=&#34;http://devblog.dwarvesf.com/images/2015-01-27-git-remote.png&#34;  /&gt;
    
    
&lt;/figure&gt;

&lt;/p&gt;

&lt;p&gt;OK. Giờ để viết blog thì các bạn chỉ cần xài các câu lệnh căn bản ở những phần trước là được.&lt;/p&gt;

&lt;p&gt;Viết bài mới:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo new path/to/file.md
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Build:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo server --watch --buildDrafts
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Deploy lên Github:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./deploy.sh &amp;quot;&amp;lt;message&amp;gt;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:45c83b4096b0a8a9601d43555bed992a:1&#34;&gt;Nếu bạn muốn kiểm soát chặt chẽ hơn về nội dung thì không cần cấp phát quyền cho các thành viên khác mà nên apply tính năng &lt;a href=&#34;https://help.github.com/articles/using-pull-requests/&#34;&gt;&lt;code&gt;Pull Request&lt;/code&gt;&lt;/a&gt; của Github
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:45c83b4096b0a8a9601d43555bed992a:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Cách cấu hình một site Hugo</title>
      <link>http://devblog.dwarvesf.com/post/gohugo-configuration/</link>
      <pubDate>Mon, 26 Jan 2015 23:49:15 +0700</pubDate>
      
      <guid>http://devblog.dwarvesf.com/post/gohugo-configuration/</guid>
      <description>

&lt;p&gt;Ở phần trước tui đã giới thiệu với các bạn Hugo là gì và các thành phần cơ bản của Hugo. Ở bài này tui sẽ tập trung đi vào cấu hình và deploy site này lên Github Pages.&lt;/p&gt;

&lt;h2 id=&#34;configuration:da422b2c8fa584de4248418c3e12be31&#34;&gt;Configuration&lt;/h2&gt;

&lt;p&gt;Cấu trúc thông thường của một site Hugo&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ▸ archetypes/
  ▸ content/
  ▸ layouts/
  ▸ static/
    config.toml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Trong đó file &lt;code&gt;config.toml&lt;/code&gt; đóng vai trò lưu trữ các cấu hình chung như: Tên site, URL, theme, social handle ..v.v. Hugo hỗ trợ đọc file config này với 3 đuôi chính: toml, yaml và json. &lt;code&gt;Json&lt;/code&gt; thì mọi người đã quá quen thuộc, &lt;code&gt;yaml&lt;/code&gt; là đuôi được sử dụng phổ biến của các file config bên ngôn ngữ Ruby, framework Octopress cũng sử dụng đuôi file này; &lt;a href=&#34;https://github.com/toml-lang/toml&#34;&gt;&lt;code&gt;toml&lt;/code&gt;&lt;/a&gt; là kiểu ngôn ngữ mới ra đời, cũng nhằm mục đích tạo những file cấu hình đơn giản, dễ đọc và dễ hiểu nhất cho cả người và máy. Các bạn có thể tham khảo thêm ở Github. Không qua thân thuộc với &lt;code&gt;toml&lt;/code&gt; nên tui quyết định vẫn giữ và sử dụng đuôi &lt;code&gt;.yaml&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Ví dụ file cấu hình của tui:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;
---

baseurl:            http://blog.dwarvesf.com/
pygmentsuseclasses: true 
theme:              hugo-incorporated

params:
  inc:
    # Blog Information
    title:        &amp;quot;Dwarves Foundation&amp;quot;
    subtitle:     &amp;quot;We are Dwarves. We love #gopher&amp;quot;
    cover_image:  cover.png
    logo:         logo.png

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;theme:da422b2c8fa584de4248418c3e12be31&#34;&gt;Theme&lt;/h2&gt;

&lt;p&gt;Hugo cung cấp một cơ chế load theme khá tiện lợi. Các theme được phát triển bởi nhiều lập trình viên khác nhau và tạo một pull request tới repository &lt;a href=&#34;https://github.com/spf13/hugoThemes&#34;&gt;spf13/hugoThemes&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Để install một theme, bạn chỉ cần clone repo mong muốn hoặc toàn bộ repo vào thư mục &lt;code&gt;themes&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone --recursive https://github.com/spf13/hugoThemes themes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Khi tiến hành chạy thử Hugo, bạn chỉ cần chọn loại theme mong muốn. Bên dưới là câu lệnh chạy server hugo với theme &lt;code&gt;hype&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo server --theme=hyde --buildDrafts
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Cấu trúc của một thư mục chứa theme khá đơn giản và hoàn toàn mô phỏng lại thư mục chứa site hiện tại. Ví dụ:&lt;/p&gt;

&lt;p&gt;
&lt;figure class=&#34;third right&#34;&gt;
    
        &lt;img src=&#34;http://devblog.dwarvesf.com/images/2015-01-26-hugo-theme-folder.png&#34;  /&gt;
    
    
&lt;/figure&gt;

&lt;/p&gt;

&lt;p&gt;Tùy loại theme mà các file cấu hình sẽ khác nhau về số lượng giá trị cần cấu hình cũng như tên gọi.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# File cấu hình theme herring-cove

name = &amp;quot;Herring Cove&amp;quot;
description = &amp;quot;Herring Cove is ported from the jekyll theme of the same name&amp;quot;
license = &amp;quot;MIT&amp;quot;
tags = [&amp;quot;blog&amp;quot;, &amp;quot;company&amp;quot;]

[author]
    name = &amp;quot;spf13&amp;quot;
    homepage = &amp;quot;http://spf13.com&amp;quot;

# If Porting existing theme
[original]
    author =  &amp;quot;arnp&amp;quot;
    repo = &amp;quot;http://www.github.com/arnp/herring-cove&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;# File cấu hình theme hugo-incorperated
---

baseurl:            http://blog.nilproductions.com/
pygmentsuseclasses: true 
theme:              hugo-incorporated

params:
  inc:
    # Blog Information
    title:        &amp;quot;Hugo Incorporated&amp;quot;
    subtitle:     &amp;quot;Modern Hugo based blog for companies&amp;quot;
    cover_image:  blog-cover.jpg
    logo:         logo.png

    # Company information
    company:      nil productions 
    url:          http://nilproductions.com/
    facebook:     
    github:       nilproductions
    twitter:      nw_iw
    gplus:        &#39;&#39;
    about_link:   http://nilproductions.com/about/

    # Product Information
    product_link: http://nilproductions.com/
    tagline:      &amp;quot;Coming up nil for quite some time.&amp;quot;

    # Comments
    disqus:
      # Eg. &amp;quot;exampleblog&amp;quot; Set to false to disable comments
      shortname:  false

    # Sharing settings
    sharing:
      twitter:    true
      facebook:   true
      gplus:      false
      hn:         true

    # Analytics     
    analytics:
      google: false # Add tracking code in _includes/_google-analytics.html

    # Google Fonts
    google_font: &#39;Droid+Sans:400,700&#39;
    
    # Setup your fonts, colors etc at _assets/stylesheets/main.scss
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;nguyên-tắc-hoạt-động:da422b2c8fa584de4248418c3e12be31&#34;&gt;Nguyên tắc hoạt động&lt;/h5&gt;

&lt;p&gt;Khi tiến hành generate các file html tĩnh, hugo sẽ lấy theme được chọn cùng với cấu hình hiện tại theo thứ tự ưu tiên từ bên ngoài vào bên trong, tức là sẽ lấy các giá trị config, style &amp;hellip; của thư mục root trước, sau đó mới đến các giá trị bên trong thư mục theme và tiến hành kết với dữ liệu trong các file markdown. Điều này giúp các ban có thể linh hoạt thay đổi cấu hình của các theme một cách dễ dàng.&lt;/p&gt;

&lt;p&gt;Mỗi theme tuy được viết cấu trúc khác nhau, nhưng đều tuân thủ theo nguyên tắc chia để trị, các thành phần sẽ được cắt nhỏ thành các partial, đến trang nào cần thì mới include vào để load lên.&lt;/p&gt;

&lt;p&gt;Hugo cho phép định nghĩa nhiều loại post khác nhau, với mỗi loại post các bạn có thể lên các layout khác nhau. Điều này tạo nên sự đa dạng cho trang web và đây cũng là một phần mà tui rất thích. Với tính năng này, tui có thể xây dựng một site với đầy đủ các phần Home, Blog, About, Jobs &amp;hellip; mà không bị gò bó như các blog framework khác. Nếu các bạn quan tâm đến tính năng này như tui thì có thể tham khảo trang &lt;a href=&#34;http://chimeraarts.org&#34;&gt;http://chimeraarts.org&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;deploy-static-site:da422b2c8fa584de4248418c3e12be31&#34;&gt;Deploy static site&lt;/h2&gt;

&lt;p&gt;Sau khi chạy câu lệnh &lt;code&gt;hugo server&lt;/code&gt;, Hugo sẽ generate folder &lt;code&gt;public/&lt;/code&gt; đầy đủ đồ chơi html, css và javascript như hình phía trên. Đến lúc này các bạn có một vài công việc có thể tự nghịch tùy vào sở thích của mình:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Custom lại một theme đã có sẵn bằng cách edit trực tiếp vào folder &lt;code&gt;themes/&lt;/code&gt; hoặc tạo thêm các file nằm rời để override các giá trị mặc định&lt;/li&gt;
&lt;li&gt;Tự một theme mới luôn cho oách &lt;a href=&#34;http://gohugo.io/themes/creation/&#34;&gt;http://gohugo.io/themes/creation/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Đưa folder &lt;code&gt;public/&lt;/code&gt; lên trên một host nào đó mà các bạn có, như vậy là xong. Bạn có thể tự dựng Raspi, xin một host free nào đó rồi upload lên .v..v. Còn tui thì tui lựa chọn &lt;a href=&#34;https://pages.github.com&#34;&gt;Github Pages&lt;/a&gt;, một tính năng khá đỉnh của Github.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Với mỗi account đăng kí, Github sẽ chọn một repo riêng (bạn phải tự tạo) với tên repo có dạng &lt;code&gt;username.github.io&lt;/code&gt;, mặc định branch &lt;code&gt;master&lt;/code&gt; để làm một site từ các html tĩnh. Bạn có thể tham khảo source code của site Dwarves Foundation hiện tại ở: &lt;a href=&#34;https://github.com/dwarvesf/dwarvesf.github.io&#34;&gt;https://github.com/dwarvesf/dwarvesf.github.io&lt;/a&gt;. Hoặc một số site khác đỉnh hơn mà tui sực nhớ:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Square: &lt;a href=&#34;https://github.com/square/square.github.io&#34;&gt;https://github.com/square/square.github.io&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Blog cá nhân của tui: &lt;a href=&#34;https://github.com/tieubao/tieubao.github.io&#34;&gt;https://github.com/tieubao/tieubao.github.io&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Rồi, bắt đầu đưa site lên thôi. Các bạn thực hiện các bước sau:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Tạo account github&lt;/li&gt;
&lt;li&gt;Tạo repository có tên &lt;code&gt;username-hugo&lt;/code&gt; để chứa source code của các file markdown&lt;/li&gt;
&lt;li&gt;Xóa folder &lt;code&gt;public/&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Push source lên trên repo vừa mới tạo bằng cách sử dụng các lệnh git quen thuộc&lt;/li&gt;
&lt;li&gt;Tạo repository có tên &lt;code&gt;username.github.io&lt;/code&gt; để chứa file tĩnh html, css, js trong folder &lt;code&gt;public/&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Chạy command &lt;code&gt;$ git submodule add git@github.com:&amp;lt;username&amp;gt;/&amp;lt;username&amp;gt;.github.io.git public&lt;/code&gt; để link repo &lt;code&gt;username.github.io&lt;/code&gt; đến thư mục public.&lt;/li&gt;
&lt;li&gt;Việc cuối cùng là tiến hành deploy folder &lt;code&gt;public/&lt;/code&gt; lên Github thôi. Để các bạn không phải lập đi lập lại các câu lệnh chạy server để generate html tĩnh, và một số câu lệnh git khác. Tác giả đã cung cấp đoạn shell sau:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/bash

echo -e &amp;quot;\033[0;32mDeploying updates to GitHub...\033[0m&amp;quot;

# Build the project. 
hugo # if using a theme, replace by `hugo -t &amp;lt;yourtheme&amp;gt;`

# Go To Public folder
cd public

# Add changes to git.
git add -A

# Commit changes.
msg=&amp;quot;Rebuilding site on `date`&amp;quot;
if [ $# -eq 1 ]
  then msg=&amp;quot;$1&amp;quot;
fi
git commit -m &amp;quot;$msg&amp;quot;

# Push source and build repos.
git push origin master

# Come Back
cd ..
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Các bạn chỉ cần vác thằng mày về, change mode +x cho nó &lt;code&gt;chmod +x deploy.sh&lt;/code&gt;. Những lần sau khi muốn deploy blog lên Github, bạn chỉ cd vào thư mục chứa site của mình, rồi chạy:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./deploy.sh &amp;quot;&amp;lt;message&amp;gt;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nếu các bạn rảnh rỗi thì có thể tìm hiểu thêm về git và submodule để có thể tự viết đoạn shell riêng cho mình. Một số người dùng Hugo cũng có viết về cách mà họ tùy biến, các bạn có thể dễ dàng tìm thấy qua Google. Thực hiện hoàn tất các việc trên, bạn có thể vào địa chỉ &lt;code&gt;https://username.github.io&lt;/code&gt; để xem lại thành quả của mình.&lt;/p&gt;

&lt;h4 id=&#34;tên-miền-riêng:da422b2c8fa584de4248418c3e12be31&#34;&gt;Tên miền riêng&lt;/h4&gt;

&lt;p&gt;Đối với các bạn chịu đầu tư mua một domain riêng cho mình, các bạn có thể thực hiện các bước sau để cấu hình:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Tạo folder &lt;code&gt;static/&lt;/code&gt; nếu chưa có&lt;/li&gt;
&lt;li&gt;Tạo file &lt;code&gt;CNAME&lt;/code&gt; có nội dung là tên miền mà bạn đã mua&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
&lt;figure class=&#34;third right&#34;&gt;
    
        &lt;img src=&#34;http://devblog.dwarvesf.com/images/2015-01-26-cname.png&#34;  /&gt;
    
    
&lt;/figure&gt;

&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Deploy lại lên Github&lt;/li&gt;
&lt;li&gt;Cấu hình URL Forwarding trên site mà các bạn đã mua domain&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
&lt;figure class=&#34;third right&#34;&gt;
    
        &lt;img src=&#34;http://devblog.dwarvesf.com/images/2015-01-26-hugo-url-forward.png&#34;  /&gt;
    
    
&lt;/figure&gt;

&lt;/p&gt;

&lt;p&gt;OK done. Bài này tui xin kết thúc tại đây, chúc các bạn thành công và vui vẻ với trang cá nhân của mình. Bài sau tui sẽ tiếp tục hướng dẫn cách mà nhiều thành viên có thể cùng viết bài trên Hugo.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Giới thiệu Hugo</title>
      <link>http://devblog.dwarvesf.com/post/gohugo-introduction/</link>
      <pubDate>Sun, 25 Jan 2015 17:05:55 +0700</pubDate>
      
      <guid>http://devblog.dwarvesf.com/post/gohugo-introduction/</guid>
      <description>

&lt;p&gt;&lt;em&gt;Bắt đầu chuỗi bài viết sẽ là những bài hướng dẫn cách tạo một site riêng cho mình, đồ chơi được tui giới thiệu sẽ toàn được viết trên ngôn ngữ golang.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Hugo là một dự án mã nguồn mở viết bằng ngôn ngữ Go bởi tác giả &lt;a href=&#34;https://github.com/spf13&#34;&gt;Steve Francia&lt;/a&gt;, dùng để phát sinh những file HTML tĩnh từ plain text. Những file HTML tĩnh này có thể dùng để làm trang web đơn giản như trang chủ hoặc blog cá nhân. Nếu bạn từng nghịch ruby thì bạn có thể hình dung Hugo là một bản sao của Blog Framework &lt;a href=&#34;http://octopress.org&#34;&gt;Octopress&lt;/a&gt; nhưng được viết bằng ngôn ngữ Go thay vì Ruby. Trang web mà các bạn đang đọc cũng được sử dụng Hugo để tạo nên. Source code được open trên &lt;a href=&#34;https://github.com/dwarvesf/dwarvesf-hugo&#34;&gt;Github&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Đến với Hugo, các bạn sẽ được trải nghiệm nhiều điều thú vị. Hugo cho phép dễ dàng tạo ra một website đơn giản, trang cá nhân, portfolio, docs, blogs mà không cần quan tâm đến việc cấu hình cơ sở dữ liệu, cài đặt blogs sẽ vui hơn bao giờ hết bằng các câu lệnh git.&lt;/p&gt;

&lt;p&gt;So sánh với các framework đang có hiện tại như WordPress và Octopress, Hugo mong muốn tạo ra một framework không quá phức tạp trong việc cấu hình như Octopress, tinh gọn và nhẹ nhàng trong xử lý và phản hồi cho người dùng hơn là sự nặng nề WordPress, đồng thời vẫn giữ được một chút chất Geeky. Ví dụ một số trang sử dụng Hugo: &lt;a href=&#34;http://gohugo.io/showcase/&#34;&gt;http://gohugo.io/showcase/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Các thông tin chi tiết hơn các bạn có thể tìm đọc ở trang chủ của &lt;a href=&#34;http://gohugo.io/overview/introduction&#34;&gt;Hugo&lt;/a&gt;. Phần bên dưới tui sẽ tập trung trình bày cách cài đặt, sử dụng và deploy một trang web được sinh ra bởi Hugo lên một trong các trang miễn phí - Github Pages.&lt;/p&gt;

&lt;h2 id=&#34;cài-đặt-hugo:656d3be2bce9c6be3008736b986e722e&#34;&gt;Cài đặt Hugo&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;Mac&lt;/em&gt;: sử dụng Homebrew &lt;code&gt;brew install hugo&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Linux&lt;/em&gt;: Download và copy file binary của hugo vào trong folder đã được append vào $PATH&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;sử-dụng-hugo:656d3be2bce9c6be3008736b986e722e&#34;&gt;Sử dụng Hugo&lt;/h2&gt;

&lt;p&gt;Document của Hugo mô tả khá rõ ràng các chức năng mà Hugo cung cấp cũng như những bước đầu tiếp cận, do đó việc viết lại là không cần thiết, các bạn có thể xem thêm tại &lt;a href=&#34;http://gohugo.io/overview/quickstart/&#34;&gt;đây&lt;/a&gt;. Bên dưới tui sẽ tổng kết một số câu lệnh cơ bản nhất gọi là.&lt;/p&gt;

&lt;p&gt;Tạo site mới:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo new site /path/to/site
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Cấu trúc được tạo ra sau khi chạy câu lệnh trên:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ▸ archetypes/
  ▸ content/
  ▸ layouts/
  ▸ static/
    config.toml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tạo thử một bài mới:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo new post/first.md
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Chạy server, mở trang &lt;code&gt;http://localhost:1313&lt;/code&gt; và xem thử kết quả nào&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo server --watch --buildDrafts
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Kết quả của tui

&lt;figure class=&#34;third right&#34;&gt;
    
        &lt;img src=&#34;http://devblog.dwarvesf.com/images/2015-01-25-result.png&#34;  /&gt;
    
    
&lt;/figure&gt;

&lt;/p&gt;

&lt;p&gt;OK vậy là đã xong bước cơ bản nhất. Phiên bản của các bạn có thể sẽ đơn giản hơn rất nhiều nhưng đừng nóng vội, ở bài sau tui sẽ hướng dẫn tiếp cách cài đặt theme và đưa trang web lên trên Github. Hẹn gặp lại sau.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>