<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <link>http://localhost:1313/</link>
    <description>Recent content on </description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Thu, 04 Feb 2016 12:00:25 +0700</lastBuildDate>
    <atom:link href="http://localhost:1313/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Docker với Microcontainers</title>
      <link>http://localhost:1313/post/tiny-container/</link>
      <pubDate>Thu, 04 Feb 2016 12:00:25 +0700</pubDate>
      
      <guid>http://localhost:1313/post/tiny-container/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Khi sử dụng docker, bạn sẽ nhanh chóng nhận ra image dùng để chạy project chiếm 1 dung lượng không nhỏ. Một image ubuntu đơn thuần cũng đã sử dụng gần 200mb nhưng bạn lại không sử dụng hết các tool có sẵn của nó. Các image khác như node, go, &amp;hellip; cũng đa phần chạy trên nền ubuntu, debian và chỉ cài đặt thêm môi trường để bạn dễ dàng deploy hơn nhưng việc download 1 image mới trở nên tốn thời gian vì dung lượng quá lớn và có vẻ như không cần thiết.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Chính vì thế, tôi đã tìm ra được 1 image mà trong đó không có gì cả, theo đúng nghĩa đen là không có gì cả :D, trừ 1 số metadata được thêm vào bởi Docker.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;docker pull scratch
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Vì vậy, có thể nói, đây là Docker image có dung lượng nhỏ nhất.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;chúng-ta-sẽ-tìm-hiểu-cách-deploy-1-app-web-với-image-này-ngay-bây-giờ-d:ae448018aa58d317917706c6bc9942d4&#34;&gt;Chúng ta sẽ tìm hiểu cách deploy 1 app web với image này ngay bây giờ :D&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Tôi sẽ demo với beego web.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Tôi không thể compile app go trong image empty này vì nó không có Go complier. Và vì đang sử dụng Mac nên tôi không thể compile 1 Linux binary. (Thực tế là chúng ta hoàn toàn có thể cross-compile nhưng tôi sẽ không đề cập ở bài viết này. Bạn có thể tham khảo tại &lt;a target=&#34;_blank&#34; href=&#34;https://golang.org/doc/install/source#environment&#34;&gt;đây&lt;/a&gt;).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Vì thế tôi cần tạo 1 môi trường để compile và docker build source Go:&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;docker run --rm -it -v &amp;quot;$GOPATH&amp;quot;:/go  -e &amp;quot;GOPATH=/go&amp;quot;  -v /var/run/docker.sock:/var/run/docker.sock -v $(which docker):$(which docker) golang bash
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Với lệnh ở trên, &lt;code&gt;--rm&lt;/code&gt; sẽ xóa container sau khi exit, &lt;code&gt;-v &amp;quot;$GOPATH&amp;quot;:/go&lt;/code&gt; share directory GOPATH của máy với container, &lt;code&gt;-e &amp;quot;GOPATH=/go&amp;quot;&lt;/code&gt;, &lt;code&gt;-v /var/run/docker.sock:/var/run/docker.sock&lt;/code&gt; dùng để chạy đc docker bên trong container (docker trong docker :D), &lt;code&gt;-v $(which docker):$(which docker)&lt;/code&gt; dùng để share command docker, golang là image môi trường để build Go binary và build image, bash để bắt đầu Bash session.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Lúc này, vì đã vào bên trong container nên tôi cd đến project &lt;code&gt;/go/src/git.dwarvesf.com/ivkean/web&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Tạo 1 Dockerfile với nội dung như sau:&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;# scratch
FROM scratch

WORKDIR /web

# copy binary into image
COPY web web

# copy other necessary files
COPY conf conf
COPY static static
COPY views views

EXPOSE 8080

ENTRYPOINT [&amp;quot;/web/web&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Build source bằng lệnh: &lt;code&gt;go build&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Và link library bằng: &lt;code&gt;CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o web .&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Build với docker: &lt;code&gt;docker build -t beego-web .&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
&lt;figure class=&#34;third right&#34;&gt;
    
        &lt;img src=&#34;http://localhost:1313/images/2016-02-04-tiny-container-docker-build.png&#34;  /&gt;
    
    
&lt;/figure&gt;

&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Image vừa tạo chỉ chiếm dung lượng 17.5MB :D&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
&lt;figure class=&#34;third right&#34;&gt;
    
        &lt;img src=&#34;http://localhost:1313/images/2016-02-04-tiny-container-run-docker-images.png&#34;  /&gt;
    
    
&lt;/figure&gt;

&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Khi đó, máy bạn đã có 1 image là beego-web, việc còn lại là:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;docker run -d -p 8080:8080 beego-web
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;
&lt;figure class=&#34;third right&#34;&gt;
    
        &lt;img src=&#34;http://localhost:1313/images/2016-02-04-tiny-container-run-bee-web.png&#34;  /&gt;
    
    
&lt;/figure&gt;

&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Chúc các bạn thành công.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Vim kết hợp cùng Golang</title>
      <link>http://localhost:1313/post/vim-go/</link>
      <pubDate>Fri, 16 Oct 2015 13:09:56 +0700</pubDate>
      
      <guid>http://localhost:1313/post/vim-go/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;Vim là một text-editor khá mạnh, được sử dụng trong môi trường máy chủ không có giao diện đồ họa. Trong bài này mình sẽ giới thiệu Vim căn bản và hướng dẫn các bạn sử dụng Vim như một IDE dành cho Go&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;vim-là-gì:d6ac5b2eecfc12afd25350cc0802f0f4&#34;&gt;Vim là gì?&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Vim là text editor cao cấp, phiên bản sau của Vi(Vim = Vi Improved), được viết bởi Bram Moolenaar, lần đầu tiên được đưa ra vào năm 1991.&lt;/li&gt;
&lt;li&gt;Vim thường được gọi à &amp;ldquo;editor dành cho dân lập trình&amp;rdquo;, tuy nhiên nó có thể hầu hết các công việc liên quan tới văn bản như sửa chữa văn bản, soạn thảo email hay sửa file configs.&lt;/li&gt;
&lt;li&gt;Vim có thể sử dụng làm IDE nhờ các plugins&lt;/li&gt;
&lt;li&gt;Vim hỗ trợ đa nền tảng.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;cài-đặt-và-config:d6ac5b2eecfc12afd25350cc0802f0f4&#34;&gt;Cài đặt và config&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Vim có thể được download tại trang &lt;a href=&#34;http://www.vim.org/download.php&#34;&gt;vim homepage&lt;/a&gt; hoặc cài đặt bằng &lt;a href=&#34;http://brew.sh/&#34;&gt;brew&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     brew install vim
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Vì một số plugins phía sau có thể cần tới lua nên các bạn nên cài với câu lệnh:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     brew install vim --with-lua
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Sau khi cài đặt xong, các bạn tạo một file .vimrc ở ~/ (file này không tự động tạo). File .vimrc này sẽ là nơi chứa toàn bộ config, plugins hay bundle cũng như các function liên quan tới vim.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Tiếp theo là cài vim plugins manager. Hiện tại mình đang sử dụng &lt;a href=&#34;https://github.com/VundleVim/Vundle.vim&#34;&gt;Vundle&lt;/a&gt;, các bạn có thể sử dụng &lt;a href=&#34;https://github.com/tpope/vim-pathogen&#34;&gt;panthogen&lt;/a&gt; nếu thích.&lt;br /&gt;
Vundle sẽ giúp các bạn trong việc config các plugins trong .vimrc, install hay update và một số việc khác.&lt;br /&gt;
Để cài đặt, các bạn clone vundle vào thư mục ~/.vim/bundle/ (thư mục .vim sẽ có sau khi cài đặt vim xong)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Copy vào .vimrc một số configs và các plugin cơ bản (chú ý dấu &amp;ldquo; trong vim là comment)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;set nocompatible              &amp;quot; be iMproved, required
filetype off                  &amp;quot; required


&amp;quot; set the runtime path to include Vundle and initialize
set rtp+=~/.vim/bundle/Vundle.vim
call vundle#begin()
&amp;quot; alternatively, pass a path where Vundle should install plugins
&amp;quot;call vundle#begin(&#39;~/some/path/here&#39;)


&amp;quot; let Vundle manage Vundle, required
Plugin &#39;VundleVim/Vundle.vim&#39;


&amp;quot; The following are examples of different formats supported.
&amp;quot; Keep Plugin commands between vundle#begin/end.
&amp;quot; plugin on GitHub repo
Plugin &#39;tpope/vim-fugitive&#39;
&amp;quot; plugin from http://vim-scripts.org/vim/scripts.html
Plugin &#39;L9&#39;
&amp;quot; Git plugin not hosted on GitHub
Plugin &#39;git://git.wincent.com/command-t.git&#39;
&amp;quot; git repos on your local machine (i.e. when working on your own plugin)
Plugin &#39;file:///home/gmarik/path/to/plugin&#39;
&amp;quot; The sparkup vim script is in a subdirectory of this repo called vim.
&amp;quot; Pass the path to set the runtimepath properly.
Plugin &#39;rstacruz/sparkup&#39;, {&#39;rtp&#39;: &#39;vim/&#39;}
&amp;quot; Avoid a name conflict with L9
Plugin &#39;user/L9&#39;, {&#39;name&#39;: &#39;newL9&#39;}


&amp;quot; All of your Plugins must be added before the following line
call vundle#end()            &amp;quot; required
filetype plugin indent on    &amp;quot; required
&amp;quot; To ignore plugin indent changes, instead use:
&amp;quot;filetype plugin on
&amp;quot;
&amp;quot; Brief help
&amp;quot; :PluginList       - lists configured plugins
&amp;quot; :PluginInstall    - installs plugins; append `!` to update or just :PluginUpdate
&amp;quot; :PluginSearch foo - searches for foo; append `!` to refresh local cache
&amp;quot; :PluginClean      - confirms removal of unused plugins; append `!` to auto-approve removal
&amp;quot;
&amp;quot; see :h vundle for more details or wiki for FAQ
&amp;quot; Put your non-Plugin stuff after this line
```
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tiếp theo để install plugins, các bạn mở vim lên và chạy command sau(bằng cách nhấn Esc):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      :PluginInstall
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Để update plugins, các bạn sử dụng&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      :PluginUpdate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Như vậy là đủ đồ chơi để các bạn có thể sử dụng Vim rồi.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;hướng-dẫn-sử-dụng-căn-bản:d6ac5b2eecfc12afd25350cc0802f0f4&#34;&gt;Hướng dẫn sử dụng căn bản.&lt;/h2&gt;

&lt;p&gt;Vim là một chương trình soạn thảo được build lần đầu tiên trên UNIX, dùng để làm việc trên môi trường ko có UI. Lúc này bàn phím chưa cũng khá thô sơ, nên các bước di chuyển trên vim hơi khác với bình thường:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
&lt;figure class=&#34;third right&#34;&gt;
    
        &lt;img src=&#34;http://localhost:1313/images/2015-10-16-hjkl.png&#34;  /&gt;
    
    
&lt;/figure&gt;


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Các bạn có thể tự tập luyện việc sử dụng các phím này bằng &lt;a href=&#34;http://vim-adventures.com/&#34;&gt;vim game&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Để mở một file với vim, các bạn dùng câu lệnh:
        &lt;code&gt;vim file_name&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Trong vim có 3 mode:&lt;br /&gt;
 &amp;ndash; Normal mode - xuất hiện khi bạn ấn Ecs, thường đi kèm đầu tiên bởi dấu &amp;ldquo;:&amp;ldquo;. Ở đây vim sẽ hiểu những gì bạn gõ vào là câu lệnh cho vim. Ví dụ:&lt;code&gt;:w&lt;/code&gt; là save văn bản, &lt;code&gt;:q&lt;/code&gt; là thoát một văn bản.&lt;br /&gt;
       Vim có ngôn ngữ riêng dành cho mình, đó là Vim script. Vim script có thể được execute ở normal mode, ví dụ, để in ra Hello world chúng ta dùng:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      :echo &amp;quot;Hello world&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;ndash; Insert mode - xuất hiện khi bạn nhấn một trong các nút sau :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      a: Insert vào phía sau con trỏ hiện tại
      A: Insert vào cuối hàng
      i: Insert vào phía trước con trỏ hiện tại
      I: Insert vào đầu hàng
      o: Insert và mở một hàng trống phía dưới
      O: Insert và mở một hàng trống phía trên       
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;ndash; Visual mode &amp;ndash; xuất hiện khi bạn ấn nút v, được dùng cho việc chọn một mảng block text lớn, có thể sử dụng vào việc copy paste hoặc comment&amp;hellip;&lt;/p&gt;

&lt;p&gt;Các bạn có thể đọc &lt;a href=&#34;http://bullium.com/support/vim.html&#34;&gt;vim command&lt;/a&gt; để biết thêm về các command trong vim.&lt;/p&gt;

&lt;h2 id=&#34;sử-dụng-vim-như-go-ide:d6ac5b2eecfc12afd25350cc0802f0f4&#34;&gt;Sử dụng Vim như Go IDE&lt;/h2&gt;

&lt;p&gt;Để sử dụng Vim như một IDE cho Go, chúng ta cần cài đặt một số plugins cho go.&lt;/p&gt;

&lt;p&gt;Quan trọng nhất là &lt;a href=&#34;https://github.com/fatih/vim-go/&#34;&gt;vim go&lt;/a&gt;. Vim go bao gồm tập hợp các thư viện hỗ trợ Go cho vim, ví dụ &lt;code&gt;godef&lt;/code&gt;
   &lt;code&gt;gofmt&lt;/code&gt; &lt;code&gt;go test&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Để cài đặt vim go, các bạn copy plugin vào file .vimrc&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   Plugin &#39;fatih/vim-go&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sau đó vào normal mode bằng cách nhấn &lt;code&gt;Esc&lt;/code&gt; và gõ command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   :PluginInstall
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Xong, lại tiếp tục gõ command để install Go binaries&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    :GoInstallBinaries 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Chỉ với Vim-go các bạn đã có thể code Go được rồi, nhưng để mọi thứ dễ nhìn hơn cũng như tăng độ hiệu quả, các bạn nên tìm và cài thêm các plugin sau&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    ack.vim
    bclose.vim
    bufexplorer
    nerdtree
    nerdcommenter
    csapprox
    vim-fugitive
    gitv
    vim-gitgutter
    syntastic
    neocomplete.vim
    neosnippet.vim
    auto-pairs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Trong số này:&lt;/p&gt;

&lt;p&gt;&amp;ndash; nerdtree: Giúp bạn tổ chức folder trong vim dưới dạng cây thư mục, dễ dàng hơn trong việc mở file và folder. Sau khi cài đặt:
  
&lt;figure class=&#34;third right&#34;&gt;
    
        &lt;img src=&#34;http://localhost:1313/images/2015-10-16-nerdtree.png&#34;  /&gt;
    
    
&lt;/figure&gt;

&lt;/p&gt;

&lt;p&gt;Nhờ plugin của git, các bạn có thể biết file nào đang sửa, thêm mới và chưa được commit.&lt;/p&gt;

&lt;p&gt;&amp;ndash; neocomplete: Hỗ trợ auto complete trong vim.
   
&lt;figure class=&#34;third right&#34;&gt;
    
        &lt;img src=&#34;http://localhost:1313/images/2015-10-16-neocomplete.png&#34;  /&gt;
    
    
&lt;/figure&gt;

&lt;/p&gt;

&lt;p&gt;&amp;ndash; autopair: Plugin giúp bạn gõ nhanh khi sử dụng các dấu &amp;ldquo; ( &amp;lsquo; [ &amp;lt; bằng cách thêm vào thành một pair &amp;ldquo;&amp;rdquo; () &amp;ldquo; [] &amp;lt;&amp;gt;&lt;/p&gt;

&lt;h2 id=&#34;cơ-chế-mapping-trong-vim:d6ac5b2eecfc12afd25350cc0802f0f4&#34;&gt;Cơ chế mapping trong Vim&lt;/h2&gt;

&lt;p&gt;Vim có một khái niệm là mapping, cho phép người dùng mode lại các tổ hợp phím để phục vụ các mục đích cá nhân.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Khi tôi nhấn key này, tôi muốn bạn làm hành động này thay vì những gì bạn hay thường làm  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ví dụ:
  Gõ vài dòng trên văn bản bằng vim, sau đó chạy command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;:map - x
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Đặt con trỏ của bạn lên văn bản và nhấn &lt;code&gt;-&lt;/code&gt;. Vim lập tức delete kí tự tại vị trí con trỏ, như là bạn đã nhấn &lt;code&gt;x&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Lúc này mapping của bạn chỉ có hiệu quả trên file text mà bạn đang edit, để mapping hoạt động trên toàn bộ các file khác, bạn cần đặt mapping vào trong file .vimrc&lt;br /&gt;
Một số loại mapping thường dùng:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  nmap    : sử dụng khi ở chế độ normal
  imap    : sử dụng trong chế độ insert
  vmap    : sử dụng trong chế độ visual
  noremap : không thể bị override bởi mapping khác
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ví dụ, khi code Go chúng ta hay dùng godef để tìm định nghĩa của hàm(biến) đó. Để sử dụng với vim-go chúng ta cần vào normal mode và gõ &lt;code&gt;:GoDef&lt;/code&gt;&lt;br /&gt;
Thay vì vậy, mình mapping lại như sau&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nnoremap &amp;lt;silent&amp;gt; df :GoDef&amp;lt;cr&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Có nghĩa là, khi mình ở chế độ normal, ấn tổ hợp df sẽ thực hiện command &lt;code&gt;:GoDef&lt;/code&gt;. Map này không bị override bởi bất kì normal map nào khác.&lt;br /&gt;
Như vậy, khi bạn muốn tìm kiếm định nghĩa một hàm hay một biến nào đó, bạn sử dụng tổ hợp phím &lt;code&gt;df&lt;/code&gt;. Việc này giảm thiểu quá trình typing đi khá nhiều.&lt;/p&gt;

&lt;p&gt;Một ví dụ về mapping khác, ví dụ mình hay sử dụng thư viện &lt;a href=&#34;https://github.com/k0kubun/pp&#34;&gt;print&lt;/a&gt; để in ra result ở terminal đẹp hơn. Việc log để debug trong Go diễn ra khá thường xuyên, vì vậy mình đặt một map như sau:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;inoremap &amp;lt;silent&amp;gt; pp pp.Println(&amp;quot;&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tức là khi mình gõ trong insert mode &lt;code&gt;pp&lt;/code&gt; nó sẽ tự chuyển thành &lt;code&gt;pp.Println(&amp;quot;&amp;quot;)&lt;/code&gt;, điều này giúp mình code nhanh hơn.&lt;/p&gt;

&lt;p&gt;Các bạn có thể đọc thêm về &lt;a href=&#34;http://vimdoc.sourceforge.net/htmldoc/map.html&#34;&gt;mapping in vim &lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;lời-kết:d6ac5b2eecfc12afd25350cc0802f0f4&#34;&gt;Lời kết&lt;/h2&gt;

&lt;p&gt;Tất cả mọi thứ dường như đã sẵn sàng! Việc còn lại của bạn là tập luyện:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Sử dụng nhuần nhuyễn cách di chuyển trong vim bằng các nút hjkl, cũng như các command cơ bản trong vim.&lt;/li&gt;
&lt;li&gt;Tìm thêm các plugins để hỗ trợ thêm cho vim. Một trang mình thấy khá hay và bổ ích về &lt;a href=&#34;http://vimawesome.com&#34;&gt;plugins cho vim&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Điểm mạnh của vim chính là customization, các bạn nên tìm cách tạo những mapping hay function giúp tăng tốc độ code.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Trên đây là những gì mình tìm hiểu được về Vim và cách sử dụng Vim để code Go. Thế giới của Vim có rất nhiều điều để có thể tìm hiểu, mong nhận được sự đóng góp của mọi người.
Nếu có điều gì muốn trao đổi, liên hệ qua mail thach@dwarvesf.com với mình nha.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Concurrency trong Go Lang</title>
      <link>http://localhost:1313/post/concurrency/</link>
      <pubDate>Tue, 15 Sep 2015 13:09:56 +0700</pubDate>
      
      <guid>http://localhost:1313/post/concurrency/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;Concurrency trong Go được đánh giá là một trong những đặc điểm nổi bật nhất của Go. Trong bài này mình sẽ trình bày một số khái niệm căn bản và đưa ra vài ví dụ của concurrency trong Go.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;tổng-quan:3a49f596dc00652ac1424563ccdd3a3f&#34;&gt;Tổng quan&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Concurrency trong một chương trình là khi chúng ta cho phép chạy nhiều hơn một công việc(task) một cách đồng thời.&lt;/li&gt;
&lt;li&gt;Concurrency không phải là Parallelism&lt;/li&gt;
&lt;li&gt;Cocurrency có vào hai khái niệm cơ bản: goroutines và channels&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;chi-tiết:3a49f596dc00652ac1424563ccdd3a3f&#34;&gt;Chi tiết&lt;/h2&gt;

&lt;p&gt;Chúng ta sẽ đi vào từng phần của Concurrency trong Go.&lt;/p&gt;

&lt;h4 id=&#34;goroutines:3a49f596dc00652ac1424563ccdd3a3f&#34;&gt;Goroutines&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Một goroutine là một hàm mà có thể chạy đồng thời với các hàm khác.&lt;/li&gt;
&lt;li&gt;Goroutines được xem như như thread nhưng nhẹ hơn, tuy nhiên nó không phải là một tiến trình(process) hay là thread của hệ thống(OS).&lt;/li&gt;
&lt;li&gt;Lý thuyết hoạt động goroutines dựa trên sự chia sẻ vùng nhớ.&lt;/li&gt;
&lt;li&gt;Sử dụng bằng cách thêm keyword &amp;ldquo;go&amp;rdquo; trước một hàm.
Ví dụ:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;func say(s string) {
    for i := 0; i &amp;lt; 5; i++ {
        time.Sleep(100 * time.Millisecond)
        fmt.Println(s)
    }
}

func main() {
    say(&amp;quot;world&amp;quot;)
    say(&amp;quot;hello&amp;quot;)
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Chạy chương trình này ta có sẽ có kết quả:&lt;/p&gt;

&lt;p&gt;
&lt;figure class=&#34;third right&#34;&gt;
    
        &lt;img src=&#34;http://localhost:1313/images/routine1.png&#34;  /&gt;
    
    
&lt;/figure&gt;


Sở dĩ có kết quả này là do hàm say(&amp;ldquo;world&amp;rdquo;) chạy xong mới tới hàm say(&amp;ldquo;hello&amp;rdquo;) được chạy.
Bây giờ ta sửa hàm main lại như sau&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
func main() {
    go say(&amp;quot;world&amp;quot;)
    say(&amp;quot;hello&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hàm say với keyword go đứng trước sẽ chạy cùng lúc với hàm say không có keyword go. Ta được kết quả:&lt;/p&gt;

&lt;p&gt;
&lt;figure class=&#34;third right&#34;&gt;
    
        &lt;img src=&#34;http://localhost:1313/images/routine2.png&#34;  /&gt;
    
    
&lt;/figure&gt;

&lt;/p&gt;

&lt;p&gt;Goroutines rất rẻ. Một goroutine được tạo ra chỉ tốn 2KB trong stack, và khi chạy xong bị huỷ bởi runtime. Chúng ta có thể sử dụng goroutines thoải mái mà không phải lo nghĩ về việc tốn kém bộ nhớ.
Chúng ta có thể define số goroutines chạy cùng lúc tối đa bằng khai báo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export GOMAXPROCS=100
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Một chương trình chạy có thể có một hoặc nhiều goroutines.
Tuy nhiên hàm main lại đặc biệt hơn. Khi hàm main() exit, tất cả các goroutines lập tức bị terminate.
Ví dụ&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main(){

  go func(){
    fmt.Println(&amp;quot;Hello&amp;quot;)
  }()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Chương trình này sẽ không cho ra kết quả gì, vì hàm anonymous trên sẽ không được thực hiện. Hàm main() exit trước, và goroutine bị terminate.
Nếu chúng ta sử dụng một cách khác:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main(){

  go func(){
    fmt.Println(&amp;quot;Hello&amp;quot;)
  }()
  time.Sleep(time.Second*5)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Chương trình sẽ cho ra kết quả là in ra Hello. Chúng ta buộc hàm goroutine phải chạy, trong trường hợp này là làm chậm quá trình kết thúc của hàm main một vài giây.&lt;/p&gt;

&lt;p&gt;Nhưng với một hàm main mà có lệnh Sleep trong một vài giây sẽ gây khó hiểu và code không đẹp đẽ lắm.
Từ đó sinh ra một khái niệm mới: WaitGroup.&lt;/p&gt;

&lt;p&gt;Một WaitGroup sẽ chờ một tập hợp goroutines kết thúc. Hàm goroutines chính sẽ thêm số goroutines mà nó muốn chờ, mỗi hàm goroutine khi chạy xong sẽ gọi Done(). Cho tới khi mà các goroutines chưa được chạy xong, thì waitgroup sẽ block chương trình tại thời điểm đó.&lt;/p&gt;

&lt;p&gt;Sử dụng WaitGroup:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
func main() {
    var message []int
    var wg sync.WaitGroup //tạo instance

    wg.Add(3) // Thêm 3 goroutines vào danh sách muốn đợi
    go func() {
        defer wg.Done() // sau khi chạy 2 lệnh dưới xong sẽ kết thúc,
                        // trả về done cho wg
        time.Sleep(time.Second * 3)
        messages[0] = 1
    }()
    go func() {
        defer wg.Done()
        time.Sleep(time.Second * 2)
        messages[1] = 2
    }()
    go func() {
        defer wg.Done()
        time.Sleep(time.Second * 1)
        messages[2] = 3
    }()
    go func() {
        for i := range messages {
            fmt.Println(i)
        }
    }()

    wg.Wait() // chừng nào chưa chạy xong chưa chạy xong 3 hàm trên,
              // block chương trình.
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Chúng ta có thể hiểu như sau: Khi wg(WaitGroup) Add n goroutines để đợi, với mỗi goroutine chạy xong, wg sẽ giảm đi 1. Hàm wg.Wait() chỉ được chạy qua khi và chỉ khi wg có số goroutines để đợi bằng 0.&lt;/p&gt;

&lt;p&gt;Thử viết lại hàm lúc nãy bằng waitgroup:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  var wg sync.WaitGroup
  wg.Add(1)
  go func() {
    defer wg.Done()
    fmt.Println(&amp;quot;Hello&amp;quot;)
  }()
  wg.Wait()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Chúng ta được kết quả tương tự.&lt;/p&gt;

&lt;h4 id=&#34;channel:3a49f596dc00652ac1424563ccdd3a3f&#34;&gt;Channel&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Channel sinh ra dùng để giao tiếp giữa 2 goroutines, bao gồm gửi và nhận dữ liệu.&lt;/li&gt;
&lt;li&gt;Channel là reference type.&lt;/li&gt;
&lt;li&gt;Về cơ bản, concept của channel là &amp;ldquo;typed pipes&amp;rdquo;. Nó tạo một đường ống liên kết giữa 2 goroutines, chúng ta có thể gửi các object phức tạp qua channel.&lt;/li&gt;
&lt;li&gt;Channel có thể dùng cho synchronization.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
&lt;figure class=&#34;third right&#34;&gt;
    
        &lt;img src=&#34;http://localhost:1313/images/channels.jpg&#34;  /&gt;
    
    
&lt;/figure&gt;

&lt;/p&gt;

&lt;p&gt;Sử dụng:
Chúng ta tạo channel bằng &lt;b&gt;make&lt;/b&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;chInt := make(chan int)
chQuacker := make(chan Quacker)
// Quacker là interface
// tất cả hàm nào implement hàm Quack() đều có thể làm việc với channel
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Channel sử dụng kí hiệu mũi tên hướng về bên trái.
Để gửi data thông qua channel:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt; chanInt &amp;lt;- 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Để nhận data từ channel&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; x := chanInt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Kiểm tra channel đóng&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; _, ok = &amp;lt;- c // ok bằng true nếu c còn mở
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Close một channel&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;close(c)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ví dụ:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
func main() {
  a := hello(&amp;quot;A&amp;quot;)
  b := hello(&amp;quot;B&amp;quot;)
  for i := 0; i &amp;lt; 5; i++ {
    fmt.Println(&amp;lt;-a) // lấy data từ channel
    fmt.Println(&amp;lt;-b)
  }
}
func hello(name string) chan string {
  c := make(chan string) // tạo instance channel
  go func() {
    for {
      c &amp;lt;- &amp;quot;Hello from&amp;quot; + name // gửi string vào channel
      time.Sleep(100 * time.Millisecond)
    }
  }()
  return c
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ta có kết quả:

&lt;figure class=&#34;third right&#34;&gt;
    
        &lt;img src=&#34;http://localhost:1313/images/channel1.png&#34;  /&gt;
    
    
&lt;/figure&gt;

&lt;/p&gt;

&lt;p&gt;Một lệnh send trên một channel sẽ block cho đến khi có một lệnh nhận có mặt trên cùng channel đó.&lt;/p&gt;

&lt;p&gt;Ví dụ:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main(){
  ch := make(chan int)
  ch &amp;lt;- 42
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Trong hàm này chúng ta cố gắng gửi 42 vào ch, nhưng không có lệnh nhận, vì vậy sẽ gặp deadlock(block forever). Tương tự cho việc nhận từ một channel trong khi nó chưa được send&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main(){
  ch := make(chan int)
  recieved := &amp;lt;- 42
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Trong Go có khái niệm select, giống switch case nhưng chỉ dành cho channel:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;select{
  case &amp;lt;- c1: // thử nhận giá trị từ channel c1
  case x := &amp;lt;- c2 // thử nhận giá trị từ c2 và gán vào x
  case c3 &amp;lt;- value  // thử gửi value vào c3
  default:
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lưu ý:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Mỗi case phải là một expression nhận hoặc gửi&lt;/li&gt;
&lt;li&gt;Tất cả các statement sẽ được duyệt qua. Nếu có một cái sẵn sàng, nó sẽ được chạy. Nếu nhiều cái cùng sẵn sàng, một case sẽ được chạy bằng cách random. Nếu không có cái nào, default sẽ được chạy.
Ví dụ, để set timeout cho một lệnh gửi, nhận của channel&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;chInt := make(chan Int)
select {
 case i := &amp;lt;- chInt:
      fmt.Println(&amp;quot;got int&amp;quot;,i)
 case &amp;lt;- time.After(time.Second * 5):
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hàm trên có nghĩa là, chờ để nhận giá trị từ channel vào i, nhưng không quá 5s.&lt;/p&gt;

&lt;h2 id=&#34;lời-kết:3a49f596dc00652ac1424563ccdd3a3f&#34;&gt;Lời kết&lt;/h2&gt;

&lt;p&gt;Trên đây là những gì mình tìm hiểu được về concurrency trong Go - một trong những miracles trong Go.
Nếu có điều gì muốn trao đổi, liên hệ qua mail thach@dwarvesf.com với mình nha.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Giới thiệu Interface trong GoLang</title>
      <link>http://localhost:1313/post/interface/</link>
      <pubDate>Thu, 10 Sep 2015 13:09:56 +0700</pubDate>
      
      <guid>http://localhost:1313/post/interface/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;Trong bài này mình sẽ trình bày những gì mình tìm hiểu được về interface trong Go, khái niệm, khai báo cũng như cách sử dụng và một vài ví dụ thực tế.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;khái-niệm:a38e724b1dfc1725327e2aea22a2a689&#34;&gt;Khái niệm&lt;/h2&gt;

&lt;p&gt;Interface là một dạng wrapper các khai báo hàm(chỉ là tên của hàm) ở mức độ prototype. Các hàm này sẽ được định nghĩa ở các lớp dẫn xuất, mỗi lớp dẫn xuất sẽ có cách định nghĩa lại hàm khác nhau tương ứng với mục đích sử dụng&lt;/p&gt;

&lt;h2 id=&#34;khai-báo:a38e724b1dfc1725327e2aea22a2a689&#34;&gt;Khai báo&lt;/h2&gt;

&lt;p&gt;Một interface với hàm SayYourName() trả về một string được khai báo như sau:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Hello interface{
	SayYourName() string 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;cách-sử-dụng:a38e724b1dfc1725327e2aea22a2a689&#34;&gt;Cách sử dụng&lt;/h2&gt;

&lt;p&gt;Interface trong Go follow concept Duck typing như sau:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;When I see a bird that walks like a duck and swims like a duck and quacks like a duck, I call that bird a duck.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Có nghĩa là nếu một con nào có thể đi như con vịt, bơi như con vịt và quạc quạc như con vịt thì tôi gọi đó là con vịt.&lt;/p&gt;

&lt;p&gt;Mình sẽ đưa một ví dụ cụ thể. Mình có struct User, struct này có một hàm SayYourName()&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
type User struct {
	FirstName, LastName string
}

func (u *User) SayYourName() string {
	return fmt.Sprintf(&amp;quot;%s %s&amp;quot;, u.FirstName, u.LastName)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Một hàm có param là interface Hello và trả về một string&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func Greet(n Hello) string {
	return fmt.Sprintf(&amp;quot;Dear %s&amp;quot;, n.SayYourName())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ở đây, hàm Greet nhận vào một param là interface Hello, và nó cũng chấp nhận &lt;b&gt;bất cứ param nào nếu nó có hàm SayYourName&lt;/b&gt;.&lt;br /&gt;
Thử chạy chương trình:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	u := &amp;amp;User{&amp;quot;Runi&amp;quot;, &amp;quot;Lazy&amp;quot;}
	fmt.Println(Greet(u))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Thật vậy ta có, kết quả &amp;ldquo;Dear Runi Lazy&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Chú ý là param truyền vào hàm Greet phải là những đối tượng có thể có chứa các hàm của riêng đối tượng đó, nhưng bắt buộc phải có  &lt;b&gt;tất cả&lt;/b&gt; những hàm của interface Hello. Giả sử thêm vào interface này một hàm Goodbye():&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Hello interface{
	SayYourName() string 
	Goodbye() string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Kết quả ta bị báo lỗi như sau:&lt;/p&gt;

&lt;p&gt;
&lt;figure class=&#34;third right&#34;&gt;
    
        &lt;img src=&#34;http://localhost:1313/images/interfacewrong.png&#34;  /&gt;
    
    
&lt;/figure&gt;

&lt;/p&gt;

&lt;h2 id=&#34;sử-dụng-interface-trong-go:a38e724b1dfc1725327e2aea22a2a689&#34;&gt;Sử dụng Interface trong Go&lt;/h2&gt;

&lt;p&gt;Ngoài interface có chứa khai báo hàm, interface còn một khái niệm là empty interface, hay interface{}.
Interface này không có hàm, cũng có nghĩa là tất cả các loại variables hay struct&amp;hellip; đều có thể thoả mãn làm param cho hàm nhận vào empty interface.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func DoSomething(v interface{}) {
   // ...
}
//Hàm này nhận vào bất cứ loại param nào.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Như vậy ta có thể sử dụng empty interface cho các hàm nào mà param truyền vào vẫn chưa xác định cụ thể. Khi vào trong hàm thì tuỳ trường hợp sẽ có các cách tuỳ biến để convert về giá trị chúng ta cần.&lt;/p&gt;

&lt;p&gt;Ví dụ, ta có hàm PrintAll nhận vào một mảng giá trị empty interface.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func PrintAll(vals []interface{}) {
    for _, val := range vals {
        fmt.Println(val)
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Trong hàm main ta tiến hành convert:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
func main() {
    names := []string{&amp;quot;stanley&amp;quot;, &amp;quot;david&amp;quot;, &amp;quot;oscar&amp;quot;}
    vals := make([]interface{}, len(names))
    for i, v := range names {
        vals[i] = v
    }
    PrintAll(vals)
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Một ví dụ khác, mình sưu tầm từ blog &lt;a href=&#34;http://jordanorelli.com/post/32665860244/how-to-use-interfaces-in-go&#34;&gt;how to use interface in Go&lt;/a&gt;:&lt;br /&gt;
Khi nhận response từ Twitter API thì date time có dạng timestamp như sau:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;Thu May 31 00:00:01 +0000 2012&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Dưới dây là một hàm dùng để in ra kiểu của timeStamp khi nhận từ response:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var input = `
{
    &amp;quot;created_at&amp;quot;: &amp;quot;Thu May 31 00:00:01 +0000 2012&amp;quot;
}
`

func main() {
    var val map[string]interface{}

    if err := json.Unmarshal([]byte(input), &amp;amp;val); err != nil {
        panic(err)
    }

    fmt.Println(val)
    for k, v := range val {
        fmt.Println(k, reflect.TypeOf(v))
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Chạy hàm trên ta được :&lt;/p&gt;

&lt;p&gt;
&lt;figure class=&#34;third right&#34;&gt;
    
        &lt;img src=&#34;http://localhost:1313/images/returntwitter.png&#34;  /&gt;
    
    
&lt;/figure&gt;

&lt;/p&gt;

&lt;p&gt;Hum.. timeStamp mà lại kiểu string thì chưa hợp lý lắm, thử parse lại về trực tiếp kiểu time.Time&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    var val map[string]time.Time
    if err := json.Unmarshal([]byte(input), &amp;amp;val); err != nil {
        panic(err)
    }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Thử chạy lại:&lt;/p&gt;

&lt;p&gt;
&lt;figure class=&#34;third right&#34;&gt;
    
        &lt;img src=&#34;http://localhost:1313/images/panicinterface.png&#34;  /&gt;
    
    
&lt;/figure&gt;

&lt;/p&gt;

&lt;p&gt;Lỗi này xảy ra vì không thể parse chuỗi kia về time.Time được (Twitter API được viết bằng Ruby, cách parse sẽ khác với Go).&lt;br /&gt;
Vậy chúng ta thử viết lại hàm parse chuỗi. Ta có interface Unmarshal, được lấy từ &lt;a href=&#34;http://golang.org/pkg/encoding/json/#Unmarshaler&#34;&gt;Encode Json Package&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Unmarshaler interface {
    UnmarshalJSON([]byte) error
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ta cần viết lại hàm UnmarshalJSON để có thể parse về timeStamp(sử dụng RubyDate)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Timestamp time.Time

func (t *Timestamp) UnmarshalJSON(b []byte) error {
     v, err := time.Parse(time.RubyDate, string(b[1:len(b)-1]))
    if err != nil {
        return err
    }
    *t = Timestamp(v)
    return nil
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Khi đó, hàm main sẽ được viết lại như sau:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	var val map[string]Timestamp

	if err := json.Unmarshal([]byte(input), &amp;amp;val); err != nil {
		panic(err)
	}

	fmt.Println(val)
	for k, v := range val {
		fmt.Println(k, reflect.TypeOf(v))
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Chạy chương trình ta được kết quả:

&lt;figure class=&#34;third right&#34;&gt;
    
        &lt;img src=&#34;http://localhost:1313/images/interfacetimestamp.png&#34;  /&gt;
    
    
&lt;/figure&gt;

&lt;/p&gt;

&lt;p&gt;Như vậy chúng ta đã vừa tạo một đối tượng có hàm UnmarshalJSON để có thể truyền vào hàm json.Unmarshal trong package encoding/json nhờ đó có được kết quả mong muốn.&lt;/p&gt;

&lt;h2 id=&#34;lời-kết:a38e724b1dfc1725327e2aea22a2a689&#34;&gt;Lời kết&lt;/h2&gt;

&lt;p&gt;Trên đây là những gì mình tìm hiểu được trong quá trình sử dụng interface trong Go. Interface là một trong những kĩ thuật đặc trưng của Go, mong nhận được ý kiến đóng góp từ các bạn.
Nếu có điều gì muốn trao đổi, liên hệ qua mail thach@dwarvesf.com với mình nha.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Hướng dẫn sử dụng Testing trong Go</title>
      <link>http://localhost:1313/post/gotest/</link>
      <pubDate>Wed, 09 Sep 2015 15:01:07 +0700</pubDate>
      
      <guid>http://localhost:1313/post/gotest/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;Như các bạn đã biết, testing trong lập trình cũng quan trọng như việc viết code. Testing đơn giản là đảm bảo phần mềm hoạt động đúng với mong muốn của khách hàng và trong quá trình sử dụng giảm thiểu khả năng xảy ra lỗi.&lt;/li&gt;
&lt;li&gt;Vậy làm thế nào để viết test trong Go? Tại sao mỗi file package của go hay có một file dạng filename_test.go đi kèm?&lt;/li&gt;
&lt;li&gt;Go cung cấp package &lt;a href=&#34;http://golang.org/pkg/testing/&#34;&gt;testing&lt;/a&gt; hỗ trợ viết test. Trong bài này mình sẽ giới thiệu cách sử dụng Unit Test trong Go bằng thư viện testify&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;cài-đặt:ee81b9c68703c564e9c4b37823ad2391&#34;&gt;Cài đặt&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;go get  &amp;quot;github.com/stretchr/testify/assert&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;code:ee81b9c68703c564e9c4b37823ad2391&#34;&gt;Code&lt;/h2&gt;

&lt;p&gt;Mình sẽ lấy ví dụ từ project của mình.&lt;br /&gt;
Mình có một hàm GetDirectLink nhận vào input là một link bài hát(trong trường hợp này thuộc website nhaccuatui) và output là một list url dùng để download trực tiếp.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package nhaccuatui


func (nct *NhacCuaTui) GetDirectLink(link string) ([]string, error) {
	if link == &amp;quot;&amp;quot; {
		return nil, errors.New(&amp;quot;Empty Link&amp;quot;)
	}

	var listStream []string
	if strings.Contains(link, song) {
		urlList := strings.Split(link, &amp;quot;.&amp;quot;)
		if len(urlList) &amp;lt; 4 {
			return nil, errors.New(&amp;quot;Wrong Format Link&amp;quot;)
		}
		req := httplib.Get(linkDownloadSong + urlList[3])

		var res ResponseNhacCuaTui
		err := req.ToJson(&amp;amp;res)
		if err != nil {
			return nil, err
		}
		if res.Data.StreamUrl == &amp;quot;&amp;quot; {
			return nil, errors.New(&amp;quot;Invalid Link&amp;quot;)
		}
		listStream = append(listStream, res.Data.StreamUrl)
		return listStream, nil
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Bây giờ mình sẽ viết test cho hàm này. Đầu tiên mình tạo file nhaccuatui_test.go chứa các function về Testing.&lt;br /&gt;
Hàm đầu tiên mình sẽ test link input vào bị rỗng.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package nhaccuatui

import (
	&amp;quot;testing&amp;quot;
	&amp;quot;github.com/stretchr/testify/assert&amp;quot;
)

var nct NhacCuaTui

func TestLinkEmptyString(t *testing.T) {
	_, err := nct.GetDirectLink(&amp;quot;&amp;quot;)
	assert.Equal(t, &amp;quot;Empty Link&amp;quot;, err.Error())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Câu lệnh assert.Equal cho phép so sánh hai giá trị, một là expected value(mình sẽ tính toán trước) và một là actual value(được trả về từ lúc chạy hàm). Trong trường hợp này sẽ trả về true khi err trả về đúng bằng &amp;ldquo;Empty String&amp;rdquo;&lt;/p&gt;

&lt;h2 id=&#34;chạy-test:ee81b9c68703c564e9c4b37823ad2391&#34;&gt;Chạy Test&lt;/h2&gt;

&lt;p&gt;Giờ chúng ta thử chạy file test trên bằng câu lệnh:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;go test

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lưu ý khi các bạn bỏ file _test.go vào trong thư mục, để chạy các file test trong các thư mục đó các bạn phải chạy câu lệnh&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;go test ./...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Mình chạy câu lệnh trên và đây là kết quả

&lt;figure class=&#34;third right&#34;&gt;
    
        &lt;img src=&#34;http://localhost:1313/images/firstresultTest.png&#34;  /&gt;
    
    
&lt;/figure&gt;

&lt;/p&gt;

&lt;p&gt;Test pass vì actual value và expected value giống nhau.&lt;/p&gt;

&lt;p&gt;Thử thay thế câu báo lỗi trả về thành Not Empty String và chạy lại go test&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	assert.Equal(t, &amp;quot;Not Empty Link&amp;quot;, err.Error())

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ta được kết quả&lt;/p&gt;

&lt;p&gt;
&lt;figure class=&#34;third right&#34;&gt;
    
        &lt;img src=&#34;http://localhost:1313/images/wrongStringReturn.png&#34;  /&gt;
    
    
&lt;/figure&gt;

&lt;/p&gt;

&lt;p&gt;Hàm assert có rất nhiều cách sử dụng, ví dụ assert.NotNil, assert.True &amp;hellip; tuỳ ý lựa chọn.&lt;/p&gt;

&lt;p&gt;Ngoài cách dùng thư viện testify các bạn có thể sử dụng các function trong testing package của Go. Mình sẽ viết lại hàm test trên bằng cách khác&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
func TestLinkEmptyString(t *testing.T) {
	t.Log(&amp;quot;Try to empty link, expect error output&amp;quot;)
	_, err :=  nct.GetDirectLink(&amp;quot;&amp;quot;)
	if err == nil {
		t.Error(&amp;quot;Expected error of not nil but it was nil instead&amp;quot;)
	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;lời-kết:ee81b9c68703c564e9c4b37823ad2391&#34;&gt;Lời kết&lt;/h2&gt;

&lt;p&gt;Trên đây là những gì mình tìm hiểu được trong quá trình implement unit testing trong Go. Còn nhiều cấp độ testing khác, rất mong nhận được đóng góp ý kiến từ các bạn.&lt;br /&gt;
Nếu có điều gì muốn trao đổi, liên hệ qua mail thach@dwarvesf.com với mình nha.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Cài đặt Sublime Text và plugins hỗ trợ code Golang</title>
      <link>http://localhost:1313/post/install-sublime-and-plugin-golang/</link>
      <pubDate>Tue, 11 Aug 2015 13:50:47 +0700</pubDate>
      
      <guid>http://localhost:1313/post/install-sublime-and-plugin-golang/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Sublime Text là một editor, được hỗ trợ syntax cho nhiều ngôn ngữ java, html, css, python, … có khá nhiều plugin phong phú và đa dạng để hỗ trợ cho việc code dễ dàng và nhanh hơn. Hôm nay tui sẽ hướng dẫn các bạn cài đặt sublime text cũng như các plugin hỗ trợ việc code Golang.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Cài đặt SublimeText:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Với Ubuntu:&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;For Sublime-Text-2:
sudo add-apt-repository ppa:webupd8team/sublime-text-2 
sudo apt-get update 
sudo apt-get install sublime-text 
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;For Sublime-Text-3:
sudo add-apt-repository ppa:webupd8team/sublime-text-3 
sudo apt-get update 
sudo apt-get install sublime-text-installer
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Với Mac:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;http://c758482.r82.cf2.rackcdn.com/Sublime%20Text%20Build%203083.dmg
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Sau khi cài đặt xong, chúng ta sẽ cài thêm các plugin như sau:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Chạy sublime text.&lt;/li&gt;
&lt;li&gt;Cài đặt Package Control. Sử dụng tổ hợp phím Ctrl + `

&lt;figure class=&#34;third right&#34;&gt;
    
        &lt;img src=&#34;http://localhost:1313/images/post/2015-08-11/Screen%20Shot%202015-08-10%20at%2010.41.43%20PM.png&#34;  /&gt;
    
    
&lt;/figure&gt;

&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Nếu là sublime 3, chúng ta paste code này:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import urllib.request,os,hashlib; h = &#39;eb2297e1a458f27d836c04bb0cbaf282&#39; + &#39;d0e7a3098092775ccb37ca9d6b2e4b7d&#39;; pf = &#39;Package Control.sublime-package&#39;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &#39;http:/ /packagecontrol.io/&#39; + pf.replace(&#39; &#39;, &#39;%20&#39;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&#39;Error validating download (got %s instead of %s), please try manual install&#39; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &#39;wb&#39; ).write(by)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nếu sublime 2, chúng ta paste code này:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import urllib2,os,hashlib; h = &#39;eb2297e1a458f27d836c04bb0cbaf282&#39; + &#39;d0e7a3098092775ccb37ca9d6b2e4b7d&#39;; pf = &#39;Package Control.sublime-package&#39;; ipp = sublime.installed_packages_path(); os.makedirs( ipp ) if not os.path.exists(ipp) else None; urllib2.install_opener( urllib2.build_opener( urllib2.ProxyHandler()) ); by = urllib2.urlopen( &#39;http://packagecontrol.io/&#39; + pf.replace(&#39; &#39;, &#39;%20&#39;)).read(); dh = hashlib.sha256(by).hexdigest(); open( os.path.join( ipp, pf), &#39;wb&#39; ).write(by) if dh == h else None; print(&#39;Error validating download (got %s instead of %s), please try manual install&#39; % (dh, h) if dh != h else &#39;Please restart Sublime Text to finish installation&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Để biết thêm chi tiết về việc cài đặt Package Control, các bạn có thể vào trang:
&lt;a href=&#34;https://packagecontrol.io/installation&#34;&gt;https://packagecontrol.io/installation&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Sau khi cài đặt Package Control, chúng ta có thể vào:

&lt;figure class=&#34;third right&#34;&gt;
    
        &lt;img src=&#34;http://localhost:1313/images/post/2015-08-11/Screen%20Shot%202015-08-10%20at%2010.44.49%20PM.png&#34;  /&gt;
    
    
&lt;/figure&gt;

&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Chọn Package Control.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
&lt;figure class=&#34;third right&#34;&gt;
    
        &lt;img src=&#34;http://localhost:1313/images/post/2015-08-11/Screen%20Shot%202015-08-10%20at%2010.47.55%20PM.png&#34;  /&gt;
    
    
&lt;/figure&gt;

&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Chọn install package và search các package cần thiết và install.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Ở đây, ta sẽ tiến hành install GoSublime và GoImport&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Với GoSublime, chúng ta có thể:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;code completion&lt;/li&gt;
&lt;li&gt;check lint/syntax Go&lt;/li&gt;
&lt;li&gt;list danh sách các biến, function được khai báo trong file&lt;/li&gt;
&lt;li&gt;và nhiều chức năng khác. Để biết thêm chi tiết về các tính năng, các bạn có thể vào trang &lt;a href=&#34;https://github.com/DisposaBoy/GoSublime&#34;&gt;https://github.com/DisposaBoy/GoSublime&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Với GoImport, chúng ta có thể tự động import hoặc remove package khỏi file hiện tại sau khi Save.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Giờ thì chúng ta tiến hành install các plugin:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Cài đặt GoImport&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Chắc chắn rằng bạn đã set GOPATH và có $GOPATH/bin. Download package GoImport về:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;go get -u golang.org/x/tools/cmd/goimports&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Cài đặt  GoSublime&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Preferences -&amp;gt; Package Control -&amp;gt; Install Package -&amp;gt; type GoSublime. Sau khi click, sublime text sẽ cài đặt plugin cho bạn.&lt;/p&gt;

&lt;p&gt;Các bạn có thể vào phần List Packages để kiểm tra các package đã được cài.&lt;/p&gt;

&lt;p&gt;Sau khi cài đặt GoSublime, ta tiến hành config như sau:

&lt;figure class=&#34;third right&#34;&gt;
    
        &lt;img src=&#34;http://localhost:1313/images/post/2015-08-11/Screen%20Shot%202015-08-10%20at%2011.10.35%20PM.png&#34;  /&gt;
    
    
&lt;/figure&gt;

&lt;/p&gt;

&lt;p&gt;Vào phần Setting – User, và copy đoạn này vào:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    &amp;quot;env&amp;quot;: {
        &amp;quot;GOPATH&amp;quot;: &amp;quot;$HOME/Documents/go:$GS_GOPATH&amp;quot;,
        &amp;quot;GOROOT&amp;quot;: &amp;quot;/usr/local/go/&amp;quot;
    },
    &amp;quot;fmt_cmd&amp;quot;: [&amp;quot;goimports&amp;quot;]
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sau đó, chúng ta restart lại sublime.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Kiểm tra&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Kiểm tra GoImport, ta tạo 1 file .go và type fmt.Println(“test”), save lại, nếu file tự động thêm package fmt thì GoImport đã được cài đặt thành công.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Sau đó, kiểm tra “code completion” của GoSublime bằng cách type fmt lần nữa, nếu hiện như hình sau, thì bạn đã cài plugin GoSublime thành công.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
&lt;figure class=&#34;third right&#34;&gt;
    
        &lt;img src=&#34;http://localhost:1313/images/post/2015-08-11/Screen%20Shot%202015-08-10%20at%2011.16.18%20PM.png&#34;  /&gt;
    
    
&lt;/figure&gt;

&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Chúc các bạn cài đặt thành công và cải thiện được tốc độ code nhanh hơn với 2 plugin trên :).&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Docker và những điều cần biết.</title>
      <link>http://localhost:1313/post/docker-introduction/</link>
      <pubDate>Sun, 09 Aug 2015 10:45:19 +0700</pubDate>
      
      <guid>http://localhost:1313/post/docker-introduction/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Gần đây Docker đang gây được nhiều chú ý trong cộng đồng công nghệ thế giới, với nhiều hứa hẹn trong tương lai. Các hãng công nghệ lớn như Google, Amazon, Microsoft, IBM, Ebay… đã bắt đầu hỗ trợ Docker trên nền tảng của họ.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Vậy Docker là gì, có gì thú vị ?  Chúng ta hãy cùng nhau điểm qua một số điều dưới đây để hiểu hơn về Docker và có thể triển khai được website Golang được viết với framework Beego.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;docker-là-gì:cdde93ef5507b118dc926636dcdb2b77&#34;&gt;Docker là gì?&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Docker là một nền tảng mở dành cho các lập trình viên, quản trị hệ thống dùng để xây dựng, vận chuyển và chạy các ứng dụng. Ban đầu viết bằng Python, hiện tại đã chuyển sang Go-lang.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;vậy-docker-khác-gì-so-với-máy-ảo:cdde93ef5507b118dc926636dcdb2b77&#34;&gt;Vậy docker khác gì so với máy ảo ?&lt;/h2&gt;

&lt;p&gt;
&lt;figure class=&#34;third right&#34;&gt;
    
        &lt;img src=&#34;http://localhost:1313/images/2015-08-09-screen-shoot-docker-compare-vm.png&#34;  /&gt;
    
    
&lt;/figure&gt;

&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Ở hình trên, ta có thể thấy như sau:

&lt;ul&gt;
&lt;li&gt;Máy ảo (virtual machine): mỗi máy ảo gồm các ứng dụng, các file nhị phân, thư viện, tất cả users hệ thống. Chúng tạo tạo nên một lượng dữ liệu rất lớn, có thể lên đến hơn 10GBs.&lt;/li&gt;
&lt;li&gt;Với Docker container: chỉ chứa những ứng dụng và những thứ cần thiết để chạy ứng dụng, có khả năng share kernel với những container khác. Chúng chạy độc lập trên hệ thống. Chúng cũng không bị hạn chế bởi cấu hình máy nào, vì docker container có thể chạy trên bất kì máy tính, bất kì cấu hình, hoặc thậm chí trên cả cloud.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;các-thành-phần-của-docker:cdde93ef5507b118dc926636dcdb2b77&#34;&gt;Các thành phần của Docker&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Docker Engine: còn được gọi là Docker, dùng để tạo và chạy các “container”&lt;/li&gt;
&lt;li&gt;Kitematic: là giao diện GUI cho Docker&lt;/li&gt;
&lt;li&gt;Docker Hub: là 1 dịch vụ host public của Docker để quản lý các image của bạn.&lt;/li&gt;
&lt;li&gt;Docker Compose: là 1 công cụ để tạo và chạy nhiều containers cùng lúc. Với Docker Compose, bạn chỉ việc định nghĩa các containers trên 1 file (text) và chạy 1 dòng lệnh duy nhất, sau đó mọi thứ sẽ được docker cài đặt, setup và chạy ứng dụng như ý bạn.&lt;/li&gt;
&lt;li&gt;Docker Trusted Registry: là dịch vụ cung cấp private image.&lt;/li&gt;
&lt;li&gt;Docker Registry: nơi để lưu trữ các images của cộng đồng Docker.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;một-số-khái-niệm:cdde93ef5507b118dc926636dcdb2b77&#34;&gt;Một số khái niệm&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Image: là 1 đối tượng chứa sẵn cấu hình. Ví dụ: image có sẵn hệ điều hành ubuntu, image có sẵn Golang, … Các thao tác với image: build, run, remove&lt;/li&gt;
&lt;li&gt;Container: là 1 đối tượng mà ứng dụng chạy trong đó. Container được tạo từ image. Các thao tác với container: ps, start, stop, restart, logs, remove&lt;/li&gt;
&lt;li&gt;Dockerfile: là 1 file (text), để định nghĩa 1 image sẽ được tạo như thế nào, gồm các ứng dụng nào được cài sẵn bên trong đó.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;tạo-web-golang-bằng-framework-beego-bằng-dockerfile:cdde93ef5507b118dc926636dcdb2b77&#34;&gt;Tạo web Golang bằng framework Beego bằng Dockerfile&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Ta bắt đầu với việc tạo 1 Dockerfile, ở đây tôi sử dụng “vi” để tạo file, với nội dung như sau:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;# vì ta chạy code golang nên ta cần image là google/golang có sẵn trên docker hub
FROM google/golang

# ta get source beego về
RUN go get github.com/astaxie/beego 
RUN go get github.com/beego/bee

# set vị trí path hiện tại
WORKDIR /gopath/src/

# tạo 1 project bằng lệnh bee new
RUN bee new app

# set vị trí path để chạy app beego
WORKDIR /gopath/src/app

# set port chạy app
EXPOSE 8080

# set lệnh để chạy app
CMD bee run
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Để biết thêm về syntax tạo 1 image bằng Dockerfile, các bạn có thể xem tại: &lt;a href=&#34;https://docs.docker.com/articles/dockerfile_best-practices/&#34;&gt;https://docs.docker.com/articles/dockerfile_best-practices/&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Ta save file lại, và chạy lệnh:&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;docker build –t beego . (các bạn đừng quên dấu . phía cuối :D)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Lệnh trên thực hiện các thao tác sau:

&lt;ol&gt;
&lt;li&gt;Đặt tag name cho image là beego.&lt;/li&gt;
&lt;li&gt;Docker build image dựa trên file Dockerfile mà ta đang đứng ở path hiện tại.&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
&lt;figure class=&#34;third right&#34;&gt;
    
        &lt;img src=&#34;http://localhost:1313/images/2015-08-09-screen-shoot-docker-init-dockerfile.png&#34;  /&gt;
    
    
&lt;/figure&gt;

&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Ta kiểm tra các images được tạo bằng lệnh:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;docker images
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;
&lt;figure class=&#34;third right&#34;&gt;
    
        &lt;img src=&#34;http://localhost:1313/images/2015-08-09-screen-shoot-docker-images.png&#34;  /&gt;
    
    
&lt;/figure&gt;

&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Sau đó, ta chạy lệnh:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;docker run –-name demo-beego-app –p 8080:8080 –d beego
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Lệnh trên thực hiện các thao tác sau:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Set name (&amp;ndash;name) cho container sẽ được tạo là demo-beego-app.&lt;/li&gt;
&lt;li&gt;Đặt map port (-p) từ port bên ngoài (bên trái) 8080 vào port bên trong docker (bên phải) là 8080.&lt;/li&gt;
&lt;li&gt;Detach container (-d) chạy background.&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Sau khi chạy lệnh trên, chúng ta đã có 1 web beego chạy trên docker container ☺. Giờ chúng ta log thử bằng browser:&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
&lt;figure class=&#34;third right&#34;&gt;
    
        &lt;img src=&#34;http://localhost:1313/images/2015-08-09-screen-shoot-docker-beego.png&#34;  /&gt;
    
    
&lt;/figure&gt;

&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Bài viết ghi lại những hiểu biết của tôi trong quá trình tìm hiểu và sử dụng Docker còn khá cơ bản. Rất mong nhận được góp ý từ các bạn ☺.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Các bạn cũng có thể tìm hiểu ở trang chủ: &lt;a href=&#34;https://docs.docker.com/index.html&#34;&gt;https://docs.docker.com/index.html&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Giới thiệu Unit Test trong Android</title>
      <link>http://localhost:1313/post/android-unitest-introduce/</link>
      <pubDate>Fri, 31 Jul 2015 23:49:15 +0700</pubDate>
      
      <guid>http://localhost:1313/post/android-unitest-introduce/</guid>
      <description>

&lt;h2 id=&#34;tổng-quan:c1448c4f97d58f7a0ebda6cc028016d9&#34;&gt;Tổng quan&lt;/h2&gt;

&lt;p&gt;Kiểm thử là một bước cần thiết để đảm bảo chất lượng khi xây dựng ứng dụng trên môi trường Android.&lt;/p&gt;

&lt;p&gt;Có nhiều loại kiểm thử có thể được tiến hành trên môi trường Android như:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Unit Testing ( Kiểm thử đơn vị )&lt;/li&gt;
&lt;li&gt;Functional Testing ( Kiểm thử chức năng )&lt;/li&gt;
&lt;li&gt;Integration Testing ( Kiểm thử tích hợp )&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Trong bài viết này, tui sẽ giới thiệu tới các bạn cách tiến hành triển khai unit test trên Android bằng cách sử dụng Robolectric.&lt;/p&gt;

&lt;h2 id=&#34;các-bước-chuẩn-bị:c1448c4f97d58f7a0ebda6cc028016d9&#34;&gt;Các bước chuẩn bị&lt;/h2&gt;

&lt;p&gt;IDE: Android Studio version 1.2.
Kiến thức nhất định về JUnit.&lt;/p&gt;

&lt;h2 id=&#34;nhắc-lại-về-junit:c1448c4f97d58f7a0ebda6cc028016d9&#34;&gt;Nhắc lại về JUnit&lt;/h2&gt;

&lt;p&gt;JUnit là một framework đơn giản thường được dùng để viết Unit Test trên môi trường Java.
Các bạn có thể xem lại về JUnit ở:
&lt;a href=&#34;https://github.com/junit-team/junit/wiki&#34;&gt;https://github.com/junit-team/junit/wiki&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Ở đây, tui chỉ nhắc những kiến thức có liên sẽ sử dụng trong unit testing trên Android để các bạn tiện theo dõi, gồm:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Aggregating test in suites -  &lt;a href=&#34;https://github.com/junit-team/junit/wiki/Aggregating-tests-in-suites&#34;&gt;https://github.com/junit-team/junit/wiki/Aggregating-tests-in-suites&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Test Fixtures - &lt;a href=&#34;https://github.com/junit-team/junit/wiki/Test-fixtures&#34;&gt;https://github.com/junit-team/junit/wiki/Test-fixtures&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Assertions - &lt;a href=&#34;https://github.com/junit-team/junit/wiki/Assertions&#34;&gt;https://github.com/junit-team/junit/wiki/Assertions&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;giới-thiệu-về-robolectric:c1448c4f97d58f7a0ebda6cc028016d9&#34;&gt;Giới thiệu về Robolectric&lt;/h2&gt;

&lt;p&gt;Robolectric là một framework cho phép bạn viết unit test và chạy chúng trên môi trường JVM mà không cần chạy ứng dụng Android một cách trực tiếp trên thiết bị.&lt;/p&gt;

&lt;p&gt;URL trang chủ: &lt;a href=&#34;http://robolectric.org&#34;&gt;http://robolectric.org&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Robolectric được viết dựa trên framework JUnit 4.&lt;/p&gt;

&lt;h2 id=&#34;sử-dụng-robolectric-trong-android-studio:c1448c4f97d58f7a0ebda6cc028016d9&#34;&gt;Sử dụng Robolectric trong Android Studio&lt;/h2&gt;

&lt;p&gt;Bây giờ, tui sẽ tạo và viết một ứng dụng Android đơn giản có sử dụng unit test bằng IDE Android Studio.
Tui tạo một project android có tên là robolectric-example
Cấu trúc project sau khi tạo xong:&lt;/p&gt;

&lt;p&gt;
&lt;figure class=&#34;third right&#34;&gt;
    
        &lt;img src=&#34;http://localhost:1313/images/2015-07-31-android-unitest-tutorial-2.png&#34;  /&gt;
    
    
&lt;/figure&gt;

&lt;/p&gt;

&lt;p&gt;Để sử dụng robolectric, trước tiên cần mở file build.gradle và chỉnh sửa dependencies vào như sau:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dependencies {
    compile fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;])
    compile &#39;com.android.support:appcompat-v7:22.2.0&#39;
    testCompile &#39;junit:junit:4.12&#39;
    testCompile &#39;org.easytesting:fest:1.0.16&#39;
    testCompile &#39;com.squareup:fest-android:1.0.8&#39;
    testCompile(&#39;org.robolectric:robolectric:3.0-rc2&#39;) {
        exclude group: &#39;commons-logging&#39;, module: &#39;commons-logging&#39;
        exclude group: &#39;org.apache.httpcomponents&#39;, module: &#39;httpclient&#39;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sau khi chỉnh sửa file build.gradle, tiến hành sync project để get các package liên quan về:&lt;/p&gt;

&lt;p&gt;
&lt;figure class=&#34;third right&#34;&gt;
    
        &lt;img src=&#34;http://localhost:1313/images/2015-07-31-android-unitest-tutorial-3.png&#34;  /&gt;
    
    
&lt;/figure&gt;

&lt;/p&gt;

&lt;p&gt;Các file java dùng cho viết unit test thường được lưu trong thư mục src/test/java/package_name như hình sau:&lt;/p&gt;

&lt;p&gt;
&lt;figure class=&#34;third right&#34;&gt;
    
        &lt;img src=&#34;http://localhost:1313/images/2015-07-31-android-unitest-tutorial-4.png&#34;  /&gt;
    
    
&lt;/figure&gt;

&lt;/p&gt;

&lt;p&gt;Các file Test nên có đuôi “Test” ở cuối tên ( ví dụ: MainActivityTest.java)&lt;/p&gt;

&lt;p&gt;Để chạy được unit test sử dụng Robolectric, với mỗi file java tạo ra để chạy kiểm thử, bạn cần thêm annotation &lt;code&gt;@RunWith(RobolectricGradleTestRunner.class)&lt;/code&gt;. Một việc nữa cần làm là cấu hình môi trường chạy kiểm thử thong qua annotation &lt;code&gt;@Config()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Ví dụ, tôi cấu hình cho file &lt;code&gt;MainActivityTest.java&lt;/code&gt; chạy unit test sử dụng Robolectric:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.example.nambv.robolectric_example;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.robolectric.Robolectric;
import org.robolectric.RobolectricGradleTestRunner;
import org.robolectric.annotation.Config;

import static org.fest.assertions.api.ANDROID.assertThat;

@RunWith(RobolectricGradleTestRunner.class)
@Config(constants = BuildConfig.class, emulateSdk = 21)
public class MainActivityTest {

    private MainActivity mActivity;

    @Before
    public void setUp() throws Exception {
        // setup
        mActivity = Robolectric.buildActivity(MainActivity.class).create().get();
    }

    @Test
    public void myActivityAppearsAsExpectedInitially() throws Exception {
        // test
        assertThat(mActivity.mClickMeButton).hasText(&amp;quot;Click Me!&amp;quot;);
        assertThat(mActivity.mHelloWorldTextView).hasText(&amp;quot;Hello world!&amp;quot;);
    }

    @Test
    public void clickingClickMeButtonChangesHelloWorldText() throws Exception {
        assertThat(mActivity.mHelloWorldTextView).hasText(&amp;quot;Hello world!&amp;quot;);
        mActivity.mClickMeButton.performClick();
        assertThat(mActivity.mHelloWorldTextView).hasText(&amp;quot;You clicked on button!&amp;quot;);
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Lưu ý: Tất cả các phương thức được implement để chạy unit test phải được khai báo ở dạng public.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Để chạy được unit test này, tui định nghĩa một TextView và một Button ở MainActivity như sau:
File &lt;code&gt;MainActivity.java&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class MainActivity extends Activity {

    Button mClickMeButton;
    TextView mHelloWorldTextView;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        mClickMeButton = (Button) findViewById(R.id.btn_click_me);
        mHelloWorldTextView = (TextView) findViewById(R.id.tv_hello_world);

        mClickMeButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                mHelloWorldTextView.setText(&amp;quot;You clicked on button!&amp;quot;);
            }
        });
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;File &lt;code&gt;activity_main.xml&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;LinearLayout xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;
    xmlns:tools=&amp;quot;http://schemas.android.com/tools&amp;quot;
    android:layout_width=&amp;quot;match_parent&amp;quot;
    android:layout_height=&amp;quot;match_parent&amp;quot;
    android:paddingLeft=&amp;quot;@dimen/activity_horizontal_margin&amp;quot;
    android:paddingRight=&amp;quot;@dimen/activity_horizontal_margin&amp;quot;
    android:paddingTop=&amp;quot;@dimen/activity_vertical_margin&amp;quot;
    android:paddingBottom=&amp;quot;@dimen/activity_vertical_margin&amp;quot;
    android:orientation=&amp;quot;vertical&amp;quot;
    tools:context=&amp;quot;.MainActivity&amp;quot;&amp;gt;

    &amp;lt;TextView
        android:id=&amp;quot;@+id/tv_hello_world&amp;quot;
        android:text=&amp;quot;@string/hello_world&amp;quot;
        android:layout_width=&amp;quot;wrap_content&amp;quot;
        android:layout_height=&amp;quot;wrap_content&amp;quot; /&amp;gt;

    &amp;lt;Button
        android:id=&amp;quot;@+id/btn_click_me&amp;quot;
        android:layout_width=&amp;quot;wrap_content&amp;quot;
        android:layout_height=&amp;quot;wrap_content&amp;quot;
        android:text=&amp;quot;@string/click_me&amp;quot;/&amp;gt;

&amp;lt;/LinearLayout&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;File &lt;code&gt;values/strings.xml&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;resources&amp;gt;
    &amp;lt;string name=&amp;quot;app_name&amp;quot;&amp;gt;robolectric-example&amp;lt;/string&amp;gt;

    &amp;lt;string name=&amp;quot;hello_world&amp;quot;&amp;gt;Hello world!&amp;lt;/string&amp;gt;
    &amp;lt;string name=&amp;quot;click_me&amp;quot;&amp;gt;Click Me!&amp;lt;/string&amp;gt;
    &amp;lt;string name=&amp;quot;action_settings&amp;quot;&amp;gt;Settings&amp;lt;/string&amp;gt;
&amp;lt;/resources&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Kịch bản test ở đây là, ban đầu TextView hiển thị nội dung là &lt;code&gt;“Hello world!”&lt;/code&gt;, khi tui click vào button &lt;code&gt;“Click Me!”&lt;/code&gt;, TextView sẽ cập nhật nội dung thành &lt;code&gt;“You clicked on button!”&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Chúng ta tiến hành xem lại các phương thức đã được implement ở file :
Trước tiên, tui khởi tạo một đối tượng &lt;code&gt;MainActivity&lt;/code&gt; kiểu &lt;code&gt;private&lt;/code&gt; và chưa gán giá trị:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private MainActivity mActivity;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tiếp theo, tui viết phương thức &lt;code&gt;setUp()&lt;/code&gt; và cho &lt;code&gt;throw Exception&lt;/code&gt; nếu  phương thức này không chạy được và có lỗi xảy ra. Lưu ý phương thức này có gắn annotation là &lt;code&gt;@Before&lt;/code&gt;, tức là nó sẽ được chạy trước khi chạy các  phương thức có gắn annotations là &lt;code&gt;@Test&lt;/code&gt;. Phương thức này thường được dùng để khai báo, định nghĩa các dữ liệu cần thiết trước khi tiến hành kiểm thử.
Lưu ý: Phương thức được gắn annotation &lt;code&gt;@Before&lt;/code&gt; sẽ được gọi trước mỗi lần chạy một unit test&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Before
public void setUp() throws Exception {
    // setup
    mActivity = Robolectric.buildActivity(MainActivity.class).create().get();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ở đây, tui tiến hành tạo và gán giá trị cho đối tượng mActivity để chắc rằng đối tượng mActivity có giá trị khác null trước khi tiến hành kiểm thử&lt;/p&gt;

&lt;p&gt;Các phương thức được viết để chạy unit test sẽ được gắn annotation là &lt;code&gt;@Test&lt;/code&gt;.
Tiếp theo là phương thức chạy kiểm thử xem MainActivity mà tui đã khởi tạo ban đầu có chạy đúng như mong đợi của tui không. Nếu không, &lt;code&gt;throw Exception&lt;/code&gt; và thông báo lỗi:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Test
public void myActivityAppearsAsExpectedInitially() throws Exception {
    // Check if button mClickMeButton has text = &amp;quot;Click Me!&amp;quot; or not
    assertThat(mActivity.mClickMeButton).hasText(&amp;quot;Click Me!&amp;quot;);
    // Check if text view mHelloWorldTextView has text = &amp;quot;Hello world!&amp;quot; or not
    assertThat(mActivity.mHelloWorldTextView).hasText(&amp;quot;Hello world!&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tui viết thêm một unit test nữa để kiểm tra xem kết quả mong đợi khi thực hiện việc click vào button để so sánh kết quả trả về và kết quả mong đợi:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Test
public void clickingClickMeButtonChangesHelloWorldText() throws Exception {
    // Text view before click
    assertThat(mActivity.mHelloWorldTextView).hasText(&amp;quot;Hello world!&amp;quot;);
    // Perform click action
    mActivity.mClickMeButton.performClick();
    // Text view after click
    assertThat(mActivity.mHelloWorldTextView).hasText(&amp;quot;You clicked on button!&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Việc chuẩn bị đã xong, thứ tự chạy của unit test sẽ được gọi như sau:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;setUp()
myActivityAppearsAsExpectedInitially()
setUp()
clickingClickMeButtonChangesHelloWorldText()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Để tiến hành chạy các Unit Test trên, trước tiên bạn vào Build Variants, và chỉnh Test Artifact thành Unit Tests:&lt;/p&gt;

&lt;p&gt;
&lt;figure class=&#34;third right&#34;&gt;
    
        &lt;img src=&#34;http://localhost:1313/images/2015-07-31-android-unitest-tutorial-5.png&#34;  /&gt;
    
    
&lt;/figure&gt;

&lt;/p&gt;

&lt;p&gt;Sau đó, bạn right-click vào package trong thư mục &lt;code&gt;src/test&lt;/code&gt; và chọn Run:&lt;/p&gt;

&lt;p&gt;
&lt;figure class=&#34;third right&#34;&gt;
    
        &lt;img src=&#34;http://localhost:1313/images/2015-07-31-android-unitest-tutorial-6.png&#34;  /&gt;
    
    
&lt;/figure&gt;

&lt;/p&gt;

&lt;p&gt;Android Studio tiến hành chạy kiểm thử:&lt;/p&gt;

&lt;p&gt;
&lt;figure class=&#34;third right&#34;&gt;
    
        &lt;img src=&#34;http://localhost:1313/images/2015-07-31-android-unitest-tutorial-7.png&#34;  /&gt;
    
    
&lt;/figure&gt;

&lt;/p&gt;

&lt;p&gt;Kết quả chạy unit test là SUCESSFUL, tức là expected result đúng với actual result:&lt;/p&gt;

&lt;p&gt;
&lt;figure class=&#34;third right&#34;&gt;
    
        &lt;img src=&#34;http://localhost:1313/images/2015-07-31-android-unitest-tutorial-8.png&#34;  /&gt;
    
    
&lt;/figure&gt;

&lt;/p&gt;

&lt;p&gt;Ngoài ra, bạn có thể xem kết quả chạy unit test trên web  bằng cách mở file &lt;code&gt;index.html&lt;/code&gt; trong folder &lt;code&gt;build/reports/tests/debug&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;
&lt;figure class=&#34;third right&#34;&gt;
    
        &lt;img src=&#34;http://localhost:1313/images/2015-07-31-android-unitest-tutorial-9.png&#34;  /&gt;
    
    
&lt;/figure&gt;

&lt;/p&gt;

&lt;p&gt;Nội dung file &lt;code&gt;index.html&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;
&lt;figure class=&#34;third right&#34;&gt;
    
        &lt;img src=&#34;http://localhost:1313/images/2015-07-31-android-unitest-tutorial-10.png&#34;  /&gt;
    
    
&lt;/figure&gt;

&lt;/p&gt;

&lt;p&gt;Bây giờ, tui sẽ tiến hành cho unit test chạy failed trong case thứ hai, bằng cách chỉnh sửa lại nội dung text view tui expect sau khi nhấn vào button “Click Me!”&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Test
public void clickingClickMeButtonChangesHelloWorldText() throws Exception {
    // Text view before click
    assertThat(mActivity.mHelloWorldTextView).hasText(&amp;quot;Hello world!&amp;quot;);
    // Perform click action
    mActivity.mClickMeButton.performClick();
    // Text view after click
    assertThat(mActivity.mHelloWorldTextView).hasText(&amp;quot;Wrong content!&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tiến hành chạy lại unit test:&lt;/p&gt;

&lt;p&gt;
&lt;figure class=&#34;third right&#34;&gt;
    
        &lt;img src=&#34;http://localhost:1313/images/2015-07-31-android-unitest-tutorial-11.png&#34;  /&gt;
    
    
&lt;/figure&gt;

&lt;/p&gt;

&lt;p&gt;Kết quả cho thấy có 1 unit test bị failed, mở lại file index.html ta sẽ thấy kết quả như sau:&lt;/p&gt;

&lt;p&gt;
&lt;figure class=&#34;third right&#34;&gt;
    
        &lt;img src=&#34;http://localhost:1313/images/2015-07-31-android-unitest-tutorial-12.png&#34;  /&gt;
    
    
&lt;/figure&gt;

&lt;/p&gt;

&lt;p&gt;Nhấn vào test case bên dưới Failed tests, sẽ thấy lỗi sai của test case này:&lt;/p&gt;

&lt;p&gt;
&lt;figure class=&#34;third right&#34;&gt;
    
        &lt;img src=&#34;http://localhost:1313/images/2015-07-31-android-unitest-tutorial-13.png&#34;  /&gt;
    
    
&lt;/figure&gt;

&lt;/p&gt;

&lt;p&gt;Kết quả mong đợi trong test case là “Wrong content!” trong khi kết quả khi chạy lại là “You clicked on button!” nên test case này bị failed và throw exception.&lt;/p&gt;

&lt;p&gt;Source code sample các bạn có thể lấy về ở &lt;a href=&#34;https://github.com/dwarvesf/robolectric-example&#34;&gt;https://github.com/dwarvesf/robolectric-example&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;conclusion:c1448c4f97d58f7a0ebda6cc028016d9&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Trên đây, tui đã giới thiệu với các bạn một ví dụ đơn giản để chạy unit test trên Android. Hy vọng bài viết giúp ích cho các bạn trong việc xây dựng và kiểm thử ứng dụng trên môi trường Android. Cảm ơn các bạn đã theo dõi, hẹn gặp lại trong các bài viết kế tiếp về Testing trên Android.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>REVEL - MVC server side web framework Cho Golang</title>
      <link>http://localhost:1313/post/revel-installation/</link>
      <pubDate>Thu, 05 Feb 2015 14:36:15 +0700</pubDate>
      
      <guid>http://localhost:1313/post/revel-installation/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Hiện tại đã có khá nhiều framework viết bằng Go giúp cho việc lập trình ứng dụng web được dễ dàng và hệ thống hơn như revel, beego, martini, goji, … Mỗi framework có những điểm mạnh riêng, nhưng ở bài này tui sẽ hướng dẫn các bạn cài đặt và viết ứng dụng myapp đầu tiên bằng REVEL.&lt;br&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Trong đó, beego và revel là 2 framework cung cấp mô hình MVC giúp chúng ta dễ dàng code và maintain hơn trong việc tạo ứng dụng web. &lt;br&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Về phía martini và goji, 2 framework này tương đối giống nhau (gần giống với nodejs), nhưng chúng không hỗ trợ render view nên theo tui sẽ thích hợp hơn khi sử dụng với mục đích làm server RESTful hay cập nhật real-time cho client. &lt;br&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Chúng ta tiếp tục so sánh giữa beego và revel:&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Hot-compile/reload:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Cả 2 đều hỗ trợ hot-compile/reload (không cần phải restart server để chạy code mới), nhưng ở beego, file được tự động compile mỗi khi có thay đổi (mỗi khi save), còn Revel thì không như vậy, Revel sẽ đợi đến khi nhận được request mới thực hiện compile code mới, ở mặt này theo tui thấy Revel có vẻ như sử dụng ít tài nguyên hơn. &lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ORM:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Revel không hỗ trợ ORM nhưng có ví dụ cách sử dụng GORP. Beego lại tự build cho mình ORM. Ở phần database, tôi sẽ hướng dẫn các bạn kết nối dễ dàng với upper.io &lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Template engine:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Cả 2 đều sử dụng template engine của Golang &lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Vấn đề dev:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Revel cho phép ta code và xem kết quả tốt hơn, chỉ việc refresh để xem kết quả, và kết quả hiện trên browser dù cho có lỗi, chúng vẫn được hiện lên browser. Beego thì không hiện lên browser, beego hiện lỗi lên console &lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Theo cá nhân tui, phần Route của Revel khá rõ ràng và gần giống như các framework PHP khác, beego thì không, nên tui sẽ thử chọn Revel để dev xem sao :D. &lt;br&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;trước-hết-là-cài-đặt-go:16b14fe962c3a7485d600cb2de0cc111&#34;&gt;Trước hết là cài đặt Go&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;sudo apt-get update&lt;/code&gt;&lt;br&gt;
&lt;code&gt;sudo apt-get install golang&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;tiếp-đến-là-git:16b14fe962c3a7485d600cb2de0cc111&#34;&gt;Tiếp đến là  git&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;sudo apt-get install git&lt;/code&gt; &lt;br&gt;
&lt;code&gt;sudo apt-get install build-essential libssl-dev libcurl4-gnutls-dev libexpat1-dev gettext unzip&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;và-cuối-cùng-là-mercurial:16b14fe962c3a7485d600cb2de0cc111&#34;&gt;Và cuối cùng là mercurial&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;sudo apt-get install python-setuptools python-dev build-essential&lt;/code&gt; &lt;br&gt;
&lt;code&gt;sudo easy_install -U mercurial&lt;/code&gt;&lt;br&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Việc cài đặt Git và mercurial cho phép &lt;code&gt;go get&lt;/code&gt; tải về một số dependencies cần thiết cho việc cài đặt revel&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;cấu-hình-gopath:16b14fe962c3a7485d600cb2de0cc111&#34;&gt;Cấu hình GOPATH&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Tạo 1 folder: &lt;code&gt;mkdir ~/goRevel&lt;/code&gt; &lt;br&gt;&lt;/li&gt;
&lt;li&gt;Thông báo cho Go biết &lt;b&gt;GOPATH&lt;/b&gt; là folder vừa tạo: &lt;code&gt;export GOPATH=~/goRevel&lt;/code&gt; &lt;br&gt;&lt;/li&gt;
&lt;li&gt;Lưu &lt;b&gt;GOPATH&lt;/b&gt; để sử dụng cho 1 shell session: &lt;code&gt;echo export GOPATH=$GOPATH &amp;gt;&amp;gt; ~/.bash_profile&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;giờ-chúng-ta-đã-có-thể-cài-đặt-revel:16b14fe962c3a7485d600cb2de0cc111&#34;&gt;Giờ chúng ta đã có thể cài đặt REVEL&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;go get github.com/REVEL/REVEL&lt;/code&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;Dòng lệnh trên thực hiện 2 việc sau:&lt;br&gt;
+ Go sử dụng git để tải repository vào &lt;code&gt;$GOPATH/src/github.com/revel/revel/&lt;/code&gt;&lt;br&gt;
+ Go tìm tất cả những dependencies cần thiết và chạy &lt;code&gt;go get&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;và-cài-đặt-revel-tool:16b14fe962c3a7485d600cb2de0cc111&#34;&gt;và cài đặt REVEL tool&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;go get github.com/REVEL/cmd/REVEL&lt;/code&gt; &lt;br&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Công cụ REVEL command line cho phép bạn tạo(new), chạy ứng dụng(run) và đóng gói ứng dụng(package) và 1 số chức năng khác để sử dụng REVEL tiện hơn.  &lt;br&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Để có thể sử dụng được các lệnh REVEL ở bất cứ đâu, bạn cần phải lưu &lt;b&gt;$GOPATH/bin&lt;/b&gt; vào .bashrc bằng cách copy 2 dòng sau vào cuối file .bashrc: &lt;br&gt;
&lt;code&gt;export GOPATH=~/goRevel&lt;/code&gt;  &lt;br&gt;
&lt;code&gt;export PATH=&amp;quot;$PATH:$GOPATH/bin&amp;quot;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;kiểm-tra-cài-đặt:16b14fe962c3a7485d600cb2de0cc111&#34;&gt;Kiểm tra cài đặt&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;revel help&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;tạo-1-ứng-dụng-web:16b14fe962c3a7485d600cb2de0cc111&#34;&gt;Tạo 1 ứng dụng web&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;cd $GOPATH&lt;/code&gt; &lt;br&gt;
&lt;code&gt;revel new myapp&lt;/code&gt; &lt;br&gt;&lt;/p&gt;

&lt;p&gt;và bạn đã có thể chạy ứng dụng bằng lệnh sau: &lt;br&gt;
    &lt;code&gt;revel run myapp&lt;/code&gt; &lt;br&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Khi đó, REVEL sẽ chạy trên localhost với port là 9000 và bạn sẽ thấy: &lt;br&gt;&lt;/p&gt;

&lt;p&gt;
&lt;figure class=&#34;third right&#34;&gt;
    
        &lt;img src=&#34;http://localhost:1313/images/2015-02-05-revel-installation-run-my-app.png&#34;  /&gt;
    
    
&lt;/figure&gt;

&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Vậy là bạn đã cài đặt và chạy thành công ứng dụng đầu tiên bằng REVEL. &lt;br&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Ở bài sau, tui sẽ hướng dẫn các bạn làm việc với Controller, View, Routing và Parameters &lt;br&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;lời-kết:16b14fe962c3a7485d600cb2de0cc111&#34;&gt;Lời kết&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Việc cài đặt và chạy ứng dụng bằng REVEL không quá khó, nhưng nó lại đem đến cho bạn môi trường mvc gần tương tự như PHP giúp bạn có thể thích nghi nhanh chóng với việc code web bằng Golang, một ngôn ngữ còn tương tối mới và đang có cộng đồng khá đông đảo. Đó là một điều khá thuận lợi cho việc phát triển mạnh hơn của Golang. &lt;br&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;Nếu có vấn đề gì trong quá trình cài đặt, xin hãy comment bên dưới hoặc có thể gửi mail đến cho tui theo địa chỉ: ivkeanle@gmail.com&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Giới thiệu về Go</title>
      <link>http://localhost:1313/post/go-introduction/</link>
      <pubDate>Wed, 28 Jan 2015 23:49:15 +0700</pubDate>
      
      <guid>http://localhost:1313/post/go-introduction/</guid>
      <description>

&lt;p&gt;Tới thời điểm này, khá nhiều ngôn ngữ đã ra đời phục vụ việc lập trình cho phía Server-side như: PHP, Ruby on Rails, Python, NodeJs&amp;hellip; Mỗi ngôn ngữ đều có những ưu khuyết điểm riêng. Ở đây, tui sẽ giới thiệu một ngôn ngữ còn khá lạ lẫm với người Việt, đó là Go - một ngôn ngữ lập trình Server-side được phát triển bởi Google.&lt;/p&gt;

&lt;h2 id=&#34;giới-thiệu-go:f8019ab515cb984996d86c9fe8eb09ec&#34;&gt;Giới thiệu Go&lt;/h2&gt;

&lt;p&gt;Go là một ngôn ngữ lập trình đồng thời (Concurrent Program) được Google giới thiệu lần đầu tiên vào nằm 2009. Go được các thành viên phát triển nói đến về một ngôn ngữ cho server, được phát triển cho cộng đồng trên nền C.&lt;/p&gt;

&lt;p&gt;Go được ví như C - rút gọn. Những gì bạn có thể viết được trên C, bạn có thể viết được trên Go với tốc độ nhanh hơn gấp 5 lần với khác biệt rất nhỏ. Có thể đối với những bạn thường lập trình trên C# hay Java thì Go nhìn có vẻ khá lạ lẫm, nhưng khi bạn đã làm quen dc với Go, bạn sẽ thấy Go khá thú vị và tốc độ lập trình rất nhanh (như tui đã đề cập trước đó)&lt;/p&gt;

&lt;p&gt;Một trong những điểm tui thích nhất ở Go là tốc độ xử lý. Trong khi C được đánh giá có tốc độ xử lý cực nhanh, thì Go chỉ bị C bỏ lại với khoảng cách rất gần! Trước khi nhìn vào benchmark của Go, tui sẽ giởi thiệu với các bạn các cú pháp syntax Go chuẩn, các kiểu dữ liệu cơ bản, và so sánh nó với C.&lt;/p&gt;

&lt;h2 id=&#34;go-một-ngôn-ngữ-server-ngắn-gọn:f8019ab515cb984996d86c9fe8eb09ec&#34;&gt;Go, một ngôn ngữ server ngắn gọn&lt;/h2&gt;

&lt;p&gt;Nói đến đây, bạn có thấy Go thú vị và hấp dẫn hơn một tẹo rồi phải không? Mong là vậy! Dù rồi hay chưa, tui sẽ tăng tính thuyết phục và đặc sắc của Go bằng cách cho bạn xem những syntax đẹp và so sánh nó với C!
Thứ nhất, khai báo biến (variable) trong Go vô cùng ngắn gọn. Thay vì khai báo cụ thể kiểu dữ liệu của biến, Go có bộ tham chiếu kiểu dữ liệu (type inference) thực hiện việc gán kiểu và khởi tạo biến cho chúng ta. Để khai báo một biến đơn giản&amp;hellip;
Trong C:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int myVar = 33;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Trong Go:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;myVar := 33
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ngắn gọn hơn C, bạn có thể thấy như thế! Không chỉ có thế, Go không đòi hỏi kết thúc câu lệnh bằng dấu “;”, trả về nhiều kết quả trong function, và có thể trả về cặp (pair) kết quả và lỗi cho bạn (result, err). Pair cũng là cách chuẩn để xử lý lỗi trong Go. Tôi sẽ đề cập kỹ hơn ở các bài viết về syntax trong Go.
Hơn vậy, bạn có thể định nghĩa một biến bằng utf-8, một điều khá mới mẻ trong Go, ví dụ:
&lt;code&gt;biếnSố := 33&lt;/code&gt;
Bây giờ, ta tiến hành xét một chương trình Hello World trong Go và C:&lt;/p&gt;

&lt;p&gt;helloworld.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
 
int main ()
{
  printf (&amp;quot;Hello World!\n&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;helloworld.go&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main
 
import (
    &amp;quot;fmt&amp;quot;
)
 
func main() {
    fmt.Println(&amp;quot;Hello World!&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Chúng ta có thể thấy được sự tương đồng giữa Go và C qua đoạn code trên
Bạn sẽ thấy được Go ngắn gọn hơn C rõ ràng hơn khi bạn viết các chương trình lớn, phức tạp và cần xử lý đồng thời (concurrency). Có một bài blog so sánh C và Go, cũng như các chi tiết về những lợi thế về syntax của Go so với C: &lt;a href=&#34;http://www.syntax-k.de/projekte/go-review&#34;&gt;http://www.syntax-k.de/projekte/go-review&lt;/a&gt;
Tiếp theo. chúng ta sẽ so sánh khả năng chịu tải của Go để xem Go có thực sự chịu tải tốt đúng như tuyên bố của những lập trình viên hay không&lt;/p&gt;

&lt;h2 id=&#34;khả-năng-chịu-tải-của-go:f8019ab515cb984996d86c9fe8eb09ec&#34;&gt;Khả năng chịu tải của Go&lt;/h2&gt;

&lt;p&gt;Hãy nhìn cách Go chạy một loạt các chương trình đơn giản nhưng lặp đi lặp lại trong bảng dưới đây:&lt;/p&gt;

&lt;p&gt;
&lt;figure class=&#34;third right&#34;&gt;
    
        &lt;img src=&#34;http://localhost:1313/images/2015-01-28-go-vs-ruby.png&#34;  /&gt;
    
    
&lt;/figure&gt;

&lt;/p&gt;

&lt;p&gt;( Website test trực tuyến: &lt;a href=&#34;http://benchmarksgame.alioth.debian.org/&#34;&gt;http://benchmarksgame.alioth.debian.org/&lt;/a&gt; )&lt;/p&gt;

&lt;p&gt;Như chúng ta thấy từ số liệu thống kê, Golang hiệu quả hơn Ruby rất nhiều!!! Trong chương trình đầu tiên - ‘fasta-redux’, Ruby mất 110 giây để thực thi xong, nhưng Go chỉ mất 1.79 giây. Nhanh hơn gấp gần 100 lần! Quá ấn tượng phải không!!!&lt;/p&gt;

&lt;p&gt;Go không chỉ ấn tượng về tốc độ xử lý, mà còn thuận lợi về xử lý đồng thời hơn hầu hết các ngôn ngữ server hiện giờ. Go sử dụng các Goroutines (tui sẽ nói rõ hơn về Goroutlines ở những bài viết sau).&lt;/p&gt;

&lt;p&gt;Go đã cung cấp được chúng ta một ngôn ngữ lập trình ở server với tốc độ cực nhanh, một cú pháp ngắn gọn, hằng trăm package mặc định hữu dụng, cơ chế xử lý đa luồng đồng thời, và vô số thư viện được phát triển bởi các lập trình viên trên khắp thế giới. Tất cả giúp chúng ta xây dựng website, server bằng Go một cách nhanh và hiệu quả nhất.&lt;/p&gt;

&lt;h2 id=&#34;tóm-tắt:f8019ab515cb984996d86c9fe8eb09ec&#34;&gt;Tóm tắt&lt;/h2&gt;

&lt;p&gt;Với tuổi đời còn khá non trẻ (từ 2009) so với những ngôn ngữ khác (C hơn 40 năm, C++ hơn 30 năm, Ruby khoảng 20 năm, Java cỡ 17 năm, C# tầm 10-12 năm&amp;hellip;) thì 5 năm thực sự là khoảng thời gian không nhiều để ta so sánh những sản phẩm nổi bật được viết và phát hành bằng Go so với những ngôn ngữ khác. Tuy nhiên, Go đang được Google và cộng đồng lập trình viên tiếp tục phát triển và hoàn thiện. Tin vui là hiện nay, cộng đồng quan tâm đến Go trên thế giới không nhỏ!&lt;/p&gt;

&lt;p&gt;Cộng đồng Go lớn nhất hiện nay trên thế giới là &lt;a href=&#34;http://blog.gopheracademy.com/&#34;&gt;&lt;code&gt;Gopherarcademy&lt;/code&gt;&lt;/a&gt;, bên cạnh đó còn có  &lt;a href=&#34;http://go.meetup.com/&#34;&gt;&lt;code&gt;GoMeetUp&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Một trong những event lớn về Go trong thời gian gần đây là ngày 23 - 25/01/2015 vừa qua, &lt;a href=&#34;http://gophergala.com/&#34;&gt;&lt;code&gt;GopherGala&lt;/code&gt;&lt;/a&gt; đã đứng ra tổ chức sự kiện Hackathon đầu tiên cho Go trên toàn thế giới&lt;/p&gt;

&lt;p&gt;Go đang dần được chấp nhận và triển khai rộng rãi trên nhiều Startup và Công ty thương mại. Nhiều nhà cung cấp Saas/ Paas sử dụng Go trong dự án của họ. Dịch vụ gửi mail &lt;a href=&#34;http://sendgrid.com/blog/convince-company-go-golang/&#34;&gt;&lt;code&gt;SendGrid&lt;/code&gt;&lt;/a&gt; cũng đang áp dụng Go để xây dựng hệ thống mạnh mẽ hơn, nhanh hơn và đáng tin cậy hơn!&lt;/p&gt;

&lt;p&gt;Túm cái váy lại, nếu bạn đang tìm kiếm một ngôn ngữ lập trình đồng thời, song song, đơn giản, sexy và tuyệt vời, hãy đến với Go!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Hướng dẫn nhiều thành viên cùng viết bài trên Hugo</title>
      <link>http://localhost:1313/post/gohugo-tips/</link>
      <pubDate>Tue, 27 Jan 2015 16:19:17 +0700</pubDate>
      
      <guid>http://localhost:1313/post/gohugo-tips/</guid>
      <description>&lt;p&gt;Tiếp theo bài trước, sau khi đã cấu hình và deploy thư mục &lt;code&gt;source/&lt;/code&gt; chứa các file &lt;code&gt;.md&lt;/code&gt; và thư mục &lt;code&gt;public/&lt;/code&gt; chứa html tĩnh đã được dịch ra thì Github của tui sẽ như sau:&lt;/p&gt;

&lt;p&gt;
&lt;figure class=&#34;third right&#34;&gt;
    
        &lt;img src=&#34;http://localhost:1313/images/2015-01-27-github-dwarves.png&#34;  /&gt;
    
    
&lt;/figure&gt;

&lt;/p&gt;

&lt;p&gt;Để các thành viên khác có thể cùng đóng góp bài viết, tui cần phải đảm bảo họ có quyền truy cập vào 2 repo đó. Các thành viên khác cần có account Github và được add vào &lt;code&gt;Setting &amp;gt; Collaborators&lt;/code&gt; của từng repo. &lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:45c83b4096b0a8a9601d43555bed992a:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:45c83b4096b0a8a9601d43555bed992a:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;
&lt;figure class=&#34;third right&#34;&gt;
    
        &lt;img src=&#34;http://localhost:1313/images/2015-01-27-github-setting.png&#34;  /&gt;
    
    
&lt;/figure&gt;

&lt;/p&gt;

&lt;p&gt;Sau khi được cấp phát quyền truy cập vào đó, với vai trò là một thành viên mới, bạn sẽ phải clone 2 repo đó về bằng câu lệnh:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone git@github.com:dwarvesf/dwarvesf-hugo.git
$ cd dwarvesf-hugo
$ git clone --recursive git@github.com:dwarvesf/dwarvesf.github.io.git public/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Dùng &lt;code&gt;git remote&lt;/code&gt; để kiểm tra xem các folder còn trỏ đúng vào các repo hay không:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git remote -v
$ cd public | git remote -v
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;
&lt;figure class=&#34;third right&#34;&gt;
    
        &lt;img src=&#34;http://localhost:1313/images/2015-01-27-git-remote.png&#34;  /&gt;
    
    
&lt;/figure&gt;

&lt;/p&gt;

&lt;p&gt;OK. Giờ để viết blog thì các bạn chỉ cần xài các câu lệnh căn bản ở những phần trước là được.&lt;/p&gt;

&lt;p&gt;Viết bài mới:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo new path/to/file.md
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Build:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo server --watch --buildDrafts
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Deploy lên Github:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./deploy.sh &amp;quot;&amp;lt;message&amp;gt;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:45c83b4096b0a8a9601d43555bed992a:1&#34;&gt;Nếu bạn muốn kiểm soát chặt chẽ hơn về nội dung thì không cần cấp phát quyền cho các thành viên khác mà nên apply tính năng &lt;a href=&#34;https://help.github.com/articles/using-pull-requests/&#34;&gt;&lt;code&gt;Pull Request&lt;/code&gt;&lt;/a&gt; của Github
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:45c83b4096b0a8a9601d43555bed992a:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Cách cấu hình một site Hugo</title>
      <link>http://localhost:1313/post/gohugo-configuration/</link>
      <pubDate>Mon, 26 Jan 2015 23:49:15 +0700</pubDate>
      
      <guid>http://localhost:1313/post/gohugo-configuration/</guid>
      <description>

&lt;p&gt;Ở phần trước tui đã giới thiệu với các bạn Hugo là gì và các thành phần cơ bản của Hugo. Ở bài này tui sẽ tập trung đi vào cấu hình và deploy site này lên Github Pages.&lt;/p&gt;

&lt;h2 id=&#34;configuration:da422b2c8fa584de4248418c3e12be31&#34;&gt;Configuration&lt;/h2&gt;

&lt;p&gt;Cấu trúc thông thường của một site Hugo&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ▸ archetypes/
  ▸ content/
  ▸ layouts/
  ▸ static/
    config.toml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Trong đó file &lt;code&gt;config.toml&lt;/code&gt; đóng vai trò lưu trữ các cấu hình chung như: Tên site, URL, theme, social handle ..v.v. Hugo hỗ trợ đọc file config này với 3 đuôi chính: toml, yaml và json. &lt;code&gt;Json&lt;/code&gt; thì mọi người đã quá quen thuộc, &lt;code&gt;yaml&lt;/code&gt; là đuôi được sử dụng phổ biến của các file config bên ngôn ngữ Ruby, framework Octopress cũng sử dụng đuôi file này; &lt;a href=&#34;https://github.com/toml-lang/toml&#34;&gt;&lt;code&gt;toml&lt;/code&gt;&lt;/a&gt; là kiểu ngôn ngữ mới ra đời, cũng nhằm mục đích tạo những file cấu hình đơn giản, dễ đọc và dễ hiểu nhất cho cả người và máy. Các bạn có thể tham khảo thêm ở Github. Không qua thân thuộc với &lt;code&gt;toml&lt;/code&gt; nên tui quyết định vẫn giữ và sử dụng đuôi &lt;code&gt;.yaml&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Ví dụ file cấu hình của tui:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;
---

baseurl:            http://blog.dwarvesf.com/
pygmentsuseclasses: true 
theme:              hugo-incorporated

params:
  inc:
    # Blog Information
    title:        &amp;quot;Dwarves Foundation&amp;quot;
    subtitle:     &amp;quot;We are Dwarves. We love #gopher&amp;quot;
    cover_image:  cover.png
    logo:         logo.png

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;theme:da422b2c8fa584de4248418c3e12be31&#34;&gt;Theme&lt;/h2&gt;

&lt;p&gt;Hugo cung cấp một cơ chế load theme khá tiện lợi. Các theme được phát triển bởi nhiều lập trình viên khác nhau và tạo một pull request tới repository &lt;a href=&#34;https://github.com/spf13/hugoThemes&#34;&gt;spf13/hugoThemes&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Để install một theme, bạn chỉ cần clone repo mong muốn hoặc toàn bộ repo vào thư mục &lt;code&gt;themes&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone --recursive https://github.com/spf13/hugoThemes themes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Khi tiến hành chạy thử Hugo, bạn chỉ cần chọn loại theme mong muốn. Bên dưới là câu lệnh chạy server hugo với theme &lt;code&gt;hype&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo server --theme=hyde --buildDrafts
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Cấu trúc của một thư mục chứa theme khá đơn giản và hoàn toàn mô phỏng lại thư mục chứa site hiện tại. Ví dụ:&lt;/p&gt;

&lt;p&gt;
&lt;figure class=&#34;third right&#34;&gt;
    
        &lt;img src=&#34;http://localhost:1313/images/2015-01-26-hugo-theme-folder.png&#34;  /&gt;
    
    
&lt;/figure&gt;

&lt;/p&gt;

&lt;p&gt;Tùy loại theme mà các file cấu hình sẽ khác nhau về số lượng giá trị cần cấu hình cũng như tên gọi.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# File cấu hình theme herring-cove

name = &amp;quot;Herring Cove&amp;quot;
description = &amp;quot;Herring Cove is ported from the jekyll theme of the same name&amp;quot;
license = &amp;quot;MIT&amp;quot;
tags = [&amp;quot;blog&amp;quot;, &amp;quot;company&amp;quot;]

[author]
    name = &amp;quot;spf13&amp;quot;
    homepage = &amp;quot;http://spf13.com&amp;quot;

# If Porting existing theme
[original]
    author =  &amp;quot;arnp&amp;quot;
    repo = &amp;quot;http://www.github.com/arnp/herring-cove&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;# File cấu hình theme hugo-incorperated
---

baseurl:            http://blog.nilproductions.com/
pygmentsuseclasses: true 
theme:              hugo-incorporated

params:
  inc:
    # Blog Information
    title:        &amp;quot;Hugo Incorporated&amp;quot;
    subtitle:     &amp;quot;Modern Hugo based blog for companies&amp;quot;
    cover_image:  blog-cover.jpg
    logo:         logo.png

    # Company information
    company:      nil productions 
    url:          http://nilproductions.com/
    facebook:     
    github:       nilproductions
    twitter:      nw_iw
    gplus:        &#39;&#39;
    about_link:   http://nilproductions.com/about/

    # Product Information
    product_link: http://nilproductions.com/
    tagline:      &amp;quot;Coming up nil for quite some time.&amp;quot;

    # Comments
    disqus:
      # Eg. &amp;quot;exampleblog&amp;quot; Set to false to disable comments
      shortname:  false

    # Sharing settings
    sharing:
      twitter:    true
      facebook:   true
      gplus:      false
      hn:         true

    # Analytics     
    analytics:
      google: false # Add tracking code in _includes/_google-analytics.html

    # Google Fonts
    google_font: &#39;Droid+Sans:400,700&#39;
    
    # Setup your fonts, colors etc at _assets/stylesheets/main.scss
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;nguyên-tắc-hoạt-động:da422b2c8fa584de4248418c3e12be31&#34;&gt;Nguyên tắc hoạt động&lt;/h5&gt;

&lt;p&gt;Khi tiến hành generate các file html tĩnh, hugo sẽ lấy theme được chọn cùng với cấu hình hiện tại theo thứ tự ưu tiên từ bên ngoài vào bên trong, tức là sẽ lấy các giá trị config, style &amp;hellip; của thư mục root trước, sau đó mới đến các giá trị bên trong thư mục theme và tiến hành kết với dữ liệu trong các file markdown. Điều này giúp các ban có thể linh hoạt thay đổi cấu hình của các theme một cách dễ dàng.&lt;/p&gt;

&lt;p&gt;Mỗi theme tuy được viết cấu trúc khác nhau, nhưng đều tuân thủ theo nguyên tắc chia để trị, các thành phần sẽ được cắt nhỏ thành các partial, đến trang nào cần thì mới include vào để load lên.&lt;/p&gt;

&lt;p&gt;Hugo cho phép định nghĩa nhiều loại post khác nhau, với mỗi loại post các bạn có thể lên các layout khác nhau. Điều này tạo nên sự đa dạng cho trang web và đây cũng là một phần mà tui rất thích. Với tính năng này, tui có thể xây dựng một site với đầy đủ các phần Home, Blog, About, Jobs &amp;hellip; mà không bị gò bó như các blog framework khác. Nếu các bạn quan tâm đến tính năng này như tui thì có thể tham khảo trang &lt;a href=&#34;http://chimeraarts.org&#34;&gt;http://chimeraarts.org&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;deploy-static-site:da422b2c8fa584de4248418c3e12be31&#34;&gt;Deploy static site&lt;/h2&gt;

&lt;p&gt;Sau khi chạy câu lệnh &lt;code&gt;hugo server&lt;/code&gt;, Hugo sẽ generate folder &lt;code&gt;public/&lt;/code&gt; đầy đủ đồ chơi html, css và javascript như hình phía trên. Đến lúc này các bạn có một vài công việc có thể tự nghịch tùy vào sở thích của mình:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Custom lại một theme đã có sẵn bằng cách edit trực tiếp vào folder &lt;code&gt;themes/&lt;/code&gt; hoặc tạo thêm các file nằm rời để override các giá trị mặc định&lt;/li&gt;
&lt;li&gt;Tự một theme mới luôn cho oách &lt;a href=&#34;http://gohugo.io/themes/creation/&#34;&gt;http://gohugo.io/themes/creation/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Đưa folder &lt;code&gt;public/&lt;/code&gt; lên trên một host nào đó mà các bạn có, như vậy là xong. Bạn có thể tự dựng Raspi, xin một host free nào đó rồi upload lên .v..v. Còn tui thì tui lựa chọn &lt;a href=&#34;https://pages.github.com&#34;&gt;Github Pages&lt;/a&gt;, một tính năng khá đỉnh của Github.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Với mỗi account đăng kí, Github sẽ chọn một repo riêng (bạn phải tự tạo) với tên repo có dạng &lt;code&gt;username.github.io&lt;/code&gt;, mặc định branch &lt;code&gt;master&lt;/code&gt; để làm một site từ các html tĩnh. Bạn có thể tham khảo source code của site Dwarves Foundation hiện tại ở: &lt;a href=&#34;https://github.com/dwarvesf/dwarvesf.github.io&#34;&gt;https://github.com/dwarvesf/dwarvesf.github.io&lt;/a&gt;. Hoặc một số site khác đỉnh hơn mà tui sực nhớ:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Square: &lt;a href=&#34;https://github.com/square/square.github.io&#34;&gt;https://github.com/square/square.github.io&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Blog cá nhân của tui: &lt;a href=&#34;https://github.com/tieubao/tieubao.github.io&#34;&gt;https://github.com/tieubao/tieubao.github.io&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Rồi, bắt đầu đưa site lên thôi. Các bạn thực hiện các bước sau:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Notes&lt;/strong&gt;: Ở bên dưới để tránh nhầm lẫn nên tui đã tách ra 2 folders rời nhau. &lt;code&gt;public/&lt;/code&gt; dành cho draft và &lt;code&gt;release/&lt;/code&gt; dành để publish.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Tạo account github&lt;/li&gt;
&lt;li&gt;Tạo repository có tên &lt;code&gt;username-hugo&lt;/code&gt; để chứa source code của các file markdown&lt;/li&gt;
&lt;li&gt;Ignore folder &lt;code&gt;public/&lt;/code&gt;, bởi vì đây là các static files được build dưới dạng draft dùng để xem ở localhost&lt;/li&gt;
&lt;li&gt;Push source lên trên repo vừa mới tạo bằng cách sử dụng các lệnh &lt;code&gt;git push&lt;/code&gt; quen thuộc&lt;/li&gt;
&lt;li&gt;Tạo repository có tên &lt;code&gt;username.github.io&lt;/code&gt; để chứa file tĩnh html, css, js trong folder &lt;code&gt;release/&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Chạy command &lt;code&gt;$ git submodule add git@github.com:&amp;lt;username&amp;gt;/&amp;lt;username&amp;gt;.github.io.git release&lt;/code&gt; để link repo &lt;code&gt;username.github.io&lt;/code&gt; đến thư mục release.&lt;/li&gt;
&lt;li&gt;Việc cuối cùng là tiến hành deploy folder &lt;code&gt;release/&lt;/code&gt; lên Github thôi. Để các bạn không phải lập đi lập lại các câu lệnh chạy server để generate html tĩnh, và một số câu lệnh git khác. Tác giả đã cung cấp đoạn shell sau:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/bash

echo -e &amp;quot;\033[0;32mDeploying updates to GitHub...\033[0m&amp;quot;

# Build the project. 
hugo -d release # if using a theme, replace by `hugo -t &amp;lt;yourtheme&amp;gt;`

# Go To Public folder
cd release

# Add changes to git.
git add -A

# Commit changes.
msg=&amp;quot;Rebuilding site on `date`&amp;quot;
if [ $# -eq 1 ]
  then msg=&amp;quot;$1&amp;quot;
fi
git commit -m &amp;quot;$msg&amp;quot;

# Push source and build repos.
git push origin master

# Come Back
cd ..
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Các bạn chỉ cần vác thằng mày về, change mode +x cho nó &lt;code&gt;chmod +x deploy.sh&lt;/code&gt;. Những lần sau khi muốn deploy blog lên Github, bạn chỉ cd vào thư mục chứa site của mình, rồi chạy:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./deploy.sh &amp;quot;&amp;lt;message&amp;gt;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nếu các bạn rảnh rỗi thì có thể tìm hiểu thêm về git và submodule để có thể tự viết đoạn shell riêng cho mình. Một số người dùng Hugo cũng có viết về cách mà họ tùy biến, các bạn có thể dễ dàng tìm thấy qua Google. Thực hiện hoàn tất các việc trên, bạn có thể vào địa chỉ &lt;code&gt;https://username.github.io&lt;/code&gt; để xem lại thành quả của mình.&lt;/p&gt;

&lt;h4 id=&#34;tên-miền-riêng:da422b2c8fa584de4248418c3e12be31&#34;&gt;Tên miền riêng&lt;/h4&gt;

&lt;p&gt;Đối với các bạn chịu đầu tư mua một domain riêng cho mình, các bạn có thể thực hiện các bước sau để cấu hình:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Tạo folder &lt;code&gt;static/&lt;/code&gt; nếu chưa có&lt;/li&gt;
&lt;li&gt;Tạo file &lt;code&gt;CNAME&lt;/code&gt; có nội dung là tên miền mà bạn đã mua&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
&lt;figure class=&#34;third right&#34;&gt;
    
        &lt;img src=&#34;http://localhost:1313/images/2015-01-26-cname.png&#34;  /&gt;
    
    
&lt;/figure&gt;

&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Deploy lại lên Github&lt;/li&gt;
&lt;li&gt;Cấu hình URL Forwarding trên site mà các bạn đã mua domain&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
&lt;figure class=&#34;third right&#34;&gt;
    
        &lt;img src=&#34;http://localhost:1313/images/2015-01-26-hugo-url-forward.png&#34;  /&gt;
    
    
&lt;/figure&gt;

&lt;/p&gt;

&lt;p&gt;OK done. Bài này tui xin kết thúc tại đây, chúc các bạn thành công và vui vẻ với trang cá nhân của mình. Bài sau tui sẽ tiếp tục hướng dẫn cách mà nhiều thành viên có thể cùng viết bài trên Hugo.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Giới thiệu Hugo</title>
      <link>http://localhost:1313/post/gohugo-introduction/</link>
      <pubDate>Sun, 25 Jan 2015 17:05:55 +0700</pubDate>
      
      <guid>http://localhost:1313/post/gohugo-introduction/</guid>
      <description>

&lt;p&gt;&lt;em&gt;Bắt đầu chuỗi bài viết sẽ là những bài hướng dẫn cách tạo một site riêng cho mình, đồ chơi được tui giới thiệu sẽ toàn được viết trên ngôn ngữ golang.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Hugo là một dự án mã nguồn mở viết bằng ngôn ngữ Go bởi tác giả &lt;a href=&#34;https://github.com/spf13&#34;&gt;Steve Francia&lt;/a&gt;, dùng để phát sinh những file HTML tĩnh từ plain text. Những file HTML tĩnh này có thể dùng để làm trang web đơn giản như trang chủ hoặc blog cá nhân. Nếu bạn từng nghịch ruby thì bạn có thể hình dung Hugo là một bản sao của Blog Framework &lt;a href=&#34;http://octopress.org&#34;&gt;Octopress&lt;/a&gt; nhưng được viết bằng ngôn ngữ Go thay vì Ruby. Trang web mà các bạn đang đọc cũng được sử dụng Hugo để tạo nên. Source code được open trên &lt;a href=&#34;https://github.com/dwarvesf/dwarvesf-hugo&#34;&gt;Github&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Đến với Hugo, các bạn sẽ được trải nghiệm nhiều điều thú vị. Hugo cho phép dễ dàng tạo ra một website đơn giản, trang cá nhân, portfolio, docs, blogs mà không cần quan tâm đến việc cấu hình cơ sở dữ liệu, cài đặt blogs sẽ vui hơn bao giờ hết bằng các câu lệnh git.&lt;/p&gt;

&lt;p&gt;So sánh với các framework đang có hiện tại như WordPress và Octopress, Hugo mong muốn tạo ra một framework không quá phức tạp trong việc cấu hình như Octopress, tinh gọn và nhẹ nhàng trong xử lý và phản hồi cho người dùng hơn là sự nặng nề WordPress, đồng thời vẫn giữ được một chút chất Geeky. Ví dụ một số trang sử dụng Hugo: &lt;a href=&#34;http://gohugo.io/showcase/&#34;&gt;http://gohugo.io/showcase/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Các thông tin chi tiết hơn các bạn có thể tìm đọc ở trang chủ của &lt;a href=&#34;http://gohugo.io/overview/introduction&#34;&gt;Hugo&lt;/a&gt;. Phần bên dưới tui sẽ tập trung trình bày cách cài đặt, sử dụng và deploy một trang web được sinh ra bởi Hugo lên một trong các trang miễn phí - Github Pages.&lt;/p&gt;

&lt;h2 id=&#34;cài-đặt-hugo:656d3be2bce9c6be3008736b986e722e&#34;&gt;Cài đặt Hugo&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;Mac&lt;/em&gt;: sử dụng Homebrew &lt;code&gt;brew install hugo&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Linux&lt;/em&gt;: Download và copy file binary của hugo vào trong folder đã được append vào $PATH&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;sử-dụng-hugo:656d3be2bce9c6be3008736b986e722e&#34;&gt;Sử dụng Hugo&lt;/h2&gt;

&lt;p&gt;Document của Hugo mô tả khá rõ ràng các chức năng mà Hugo cung cấp cũng như những bước đầu tiếp cận, do đó việc viết lại là không cần thiết, các bạn có thể xem thêm tại &lt;a href=&#34;http://gohugo.io/overview/quickstart/&#34;&gt;đây&lt;/a&gt;. Bên dưới tui sẽ tổng kết một số câu lệnh cơ bản nhất gọi là.&lt;/p&gt;

&lt;p&gt;Tạo site mới:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo new site /path/to/site
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Cấu trúc được tạo ra sau khi chạy câu lệnh trên:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ▸ archetypes/
  ▸ content/
  ▸ layouts/
  ▸ static/
    config.toml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tạo thử một bài mới:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo new post/first.md
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Chạy server, mở trang &lt;code&gt;http://localhost:1313&lt;/code&gt; và xem thử kết quả nào&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo server --watch --buildDrafts
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Kết quả của tui

&lt;figure class=&#34;third right&#34;&gt;
    
        &lt;img src=&#34;http://localhost:1313/images/2015-01-25-result.png&#34;  /&gt;
    
    
&lt;/figure&gt;

&lt;/p&gt;

&lt;p&gt;OK vậy là đã xong bước cơ bản nhất. Phiên bản của các bạn có thể sẽ đơn giản hơn rất nhiều nhưng đừng nóng vội, ở bài sau tui sẽ hướng dẫn tiếp cách cài đặt theme và đưa trang web lên trên Github. Hẹn gặp lại sau.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Tontatta Kingdom, the Dwarves Foundation</title>
      <link>http://localhost:1313/post/tontatta-kingdom/</link>
      <pubDate>Sun, 11 Jan 2015 01:48:49 +0700</pubDate>
      
      <guid>http://localhost:1313/post/tontatta-kingdom/</guid>
      <description>&lt;p&gt;We are a team in Saigon, Vietnam. We are young and eager to learn. We have passion and experience in making cool products, esp. cloud and mobile apps. We want to help people solve their problems by using our solutions.&lt;/p&gt;

&lt;p&gt;2015 is coming. We come up with the idea that we should have new resolutions for new year to challenge ourselves &lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:add43e3d749ee5dc8702dcd488a7adc0:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:add43e3d749ee5dc8702dcd488a7adc0:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;. So we choose Google Go, a so-called new language that had grown fast and faster recently. We have found the Golang community that stick together and move forward day by day. Based on some articles &lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:add43e3d749ee5dc8702dcd488a7adc0:2&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:add43e3d749ee5dc8702dcd488a7adc0:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;,&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:add43e3d749ee5dc8702dcd488a7adc0:3&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:add43e3d749ee5dc8702dcd488a7adc0:3&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;, I see that Go will be a bright candidate for building MVP, as same as powerful platform. Many companies had moved their product to Golang like Github, Dropbox, Koding &amp;hellip;&lt;/p&gt;

&lt;p&gt;
&lt;figure class=&#34;third right&#34;&gt;
    
        &lt;img src=&#34;http://localhost:1313/images/2015-01-11-gopher.jpg&#34;  /&gt;
    
    
&lt;/figure&gt;

&lt;/p&gt;

&lt;p&gt;Currently, Golang is not popular in Vietnam. Developers are playing with Rails, Django, MEAN stack and a lot of PHP. It&amp;rsquo;s too boring. So that we build this page and want to bring Golang to Vietnam, make it become a big dot in Go world map.&lt;/p&gt;

&lt;p&gt;We call ourselves &lt;code&gt;dwarves&lt;/code&gt;, the small and misshapen creatures in Norse Mythology. We are wisdom, natural good at smithing, mining, and crafting. We live under the Tontatta Kingdom, a kingdom underneath Green Bit, and home to the Tontatta Tribe (トンタッタ族 Tontatta-zoku?), a tribe of dwarves ruled by king Gancho. We are the combination of Western and Eastern civilization.&lt;/p&gt;

&lt;p&gt;We love to make things. Our friends are gopher. We love #go.
If you want to build something that fun and helpful, just bring it to us. We will craft it in #go.&lt;/p&gt;

&lt;p&gt;If you want to support, just follow our page and give us a kudos.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Facebook: &lt;a href=&#34;https://www.facebook.com/dwarvesf&#34;&gt;https://www.facebook.com/dwarvesf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Twitter: &lt;a href=&#34;https://twitter.com/dwarvesf&#34;&gt;https://twitter.com/dwarvesf&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;And finally, if you want to join us, just leave us a message.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:add43e3d749ee5dc8702dcd488a7adc0:1&#34;&gt;&lt;a href=&#34;http://matt.might.net/articles/programmers-resolutions/&#34;&gt;12 resolutions for programmers&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:add43e3d749ee5dc8702dcd488a7adc0:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:add43e3d749ee5dc8702dcd488a7adc0:2&#34;&gt;&lt;a href=&#34;http://thenewstack.io/from-node-js-to-go-why-one-startup-made-the-switch/&#34;&gt;From Node.js To Go, Why One Startup Made The Switch&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:add43e3d749ee5dc8702dcd488a7adc0:2&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:add43e3d749ee5dc8702dcd488a7adc0:3&#34;&gt;&lt;a href=&#34;http://startupedmonton.tumblr.com/post/107921476571/why-tech-startups-should-look-at-go&#34;&gt;Why Tech Startups Should Look At Go&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:add43e3d749ee5dc8702dcd488a7adc0:3&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>